\documentclass[00-main.tex]{subfiles}
\standalonetrue
\setcounter{section}{2}
\pagestyle{footer}

% WARNING do not replace, for any reason
\usepackage{set-minted}

% NOTE non spostare, utilizzato solo qui al momento
% https://tex.stackexchange.com/questions/254044/
\newenvironment{code}{\captionsetup{type=listing}}{}
\SetupFloatingEnvironment{listing}{name=Codice}

% arara: pdflatex: { shell: yes, draft: yes, synctex: no }
% arara: pdflatex: { shell: yes, synctex: yes }
% arara: latexmk: { clean: partial }
\begin{document}

\section{Strutture dati}

\subsection{Strutture dati astratte}

\begin{fquote}[Steven S. Skiena][The Algorithm Design Manual]%
	Picking the wrong data structure for the job can be disastrous in terms of performance.
	Identifying the very best data structure is usually not as critical, because there can be several choices that perform similarly.
\end{fquote}

\subsection*{Alcune definizioni}

\begin{definition}[Tipo di dato]
In un linguaggio di programmazione, un dato è un valore che una variabile può assumere.
\end{definition}

\begin{definition}[Tipo di dato astratto]
Un modello matematico, dato da una collezione di valori e un insieme di operazioni ammesse su questi valori.
\end{definition}

\begin{definition}[Tipi di dato primitivi]
Sono dei tipi di dati che vengono forniti direttamente dal linguaggio.
Come ad esempio: int (\texttt{+,-,*,/, \%}), boolean (\texttt{!, \&\&, ||}).
\end{definition}

Ogni tipo di dato deve distinguere \emph{specifica} ed \emph{implementazione} di un tipo di dato astratto.
La \emph{specifica} è astratta, il \enquote{manuale d'uso} che nasconde i dettagli implementativi all'utente, mentre l'\emph{implementazione} è la realizzazione vera e propria del tipo di dato.

\begin{table}[H]
	\centering
	\caption{Differenza fra specifica ed implementazione}
	\label{tab:differenza-specifica-implementazione}
	\begin{tabular}{@{} *{2}{l} @{}}
		\toprule
			Specifica & Implementazione \\
		\midrule
			Numeri reali & IEEE-754\\
		\addlinespace
			\multirow{2}{*}{Pile} & Pile basate su vettori\\
								  & Pile basate su puntatori\\
	    \addlinespace
			\multirow{2}{*}{Code} & Code basate su vettori circolari\\
								  & Code basate su puntatori\\
		\bottomrule
	\end{tabular}
\end{table}

\begin{definition}[Strutture di dati]
Le strutture di dati sono collezioni di dati, caratterizzate più dall'organizzazione della collezione piuttosto che dal tipo dei dati contenuti.
\end{definition}

Le strutture dati sono un modo sistematico per organizzare i dati e su di esse sono definite un insieme di operatori che permettono di manipolare la struttura stessa.
Le strutture dati possono essere caratterizzare in vari modi, possono essere:
\begin{itemize}
	\item \emph{lineari} o \emph{non lineari}: presentano una sequenza al loro interno o meno;
	\item \emph{statiche} o \emph{dinamiche}: possono variare di dimensione o di contenuto;
	\item \emph{omogenee} o \emph{disomogenee}: si riferisce ai dati contenuti al loro interno.
\end{itemize}

\begin{table}[H]
	\centering
	\caption{Implementazione delle strutture dati nei vari linguaggi, nota che Java distingue chiaramente la specifica dall'implementazione}
	\label{tab:strutture-dati}
	\begin{tabular}{@{} l >{\ttfamily}l >{\ttfamily}l >{\ttfamily}l @{}}
	\toprule
		Tipo & \normalfont{Java} & \normalfont{\texttt{C++}} & \normalfont{Python} \\
	\midrule
		Sequenze & \makecell[l]{\alert{List, Queue, Deque},\\LinkedList, ArrayList,\\Stack, ArrayDeque} & \makecell[l]{list, forward\_list,\\vector, stack,\\queue, dequeue} & \makecell[l]{list,\\tuple}\\
	\midrule
		Insiemi & \makecell[l]{\alert{Set},\\TreeSet, HashSet,\\LinkedHashSet} & \makecell[l]{set,\\unordered\_set} & \makecell[l]{set,\\fronzenset}\\
	\midrule
		Dizionari & \makecell[l]{\alert{Map},\\HashTree, HashMap,\\LinkedHashMap} & \makecell[l]{map,\\unordered\_map} & \makecell[l]{dict}\\
	\midrule
		Alberi & \makecell[cc]{-} & \makecell[cc]{-} & \makecell[cc]{-}\\
	\midrule
		Grafi  & \makecell[cc]{-} & \makecell[cc]{-} & \makecell[cc]{-}\\
	\bottomrule
	\end{tabular}
\end{table}

\subsection{Sequenza}

Una sequenza è una struttura dati \emph{dinamica}, \emph{lineare} che rappresenta una sequenza \emph{ordinata} di valori, dove un valore può comparire più di una volta.
L'ordine all'interno della sequenza è importante.

\medskip
Le operazioni ammesse su una sequenza sono:
\begin{itemize}
	\item L'aggiunta e la rimozione elementi, specificando la posizione (tipicamente un intero), l'elemento \(s_1\) si trova in posizione \({pos}_i\) ed esistono posizioni fittizie \({pos}_0\) e \({pos}_{n+1}\);
	\item Accesso diretto alla testa e coda;
	\item Accesso sequenziale a tutti gli altri elementi.
\end{itemize}

\input{assets/algorithms/04/sequence-interface}

\subsubsection{Implementazione delle sequenze nei diversi linguaggi}

\begin{code}
\captionof{listing}{Implementazione delle liste in Java}
\label{code:java-sequence}
\begin{minted}{java}
List<String> lista = new LinkedList<String>();
lista.add("two");
lista.addFirst("one");
lista.addLast("three");

Result: [ "one", "two", "three" ]
\end{minted}
\end{code}

\begin{code}
\captionof{listing}{Implementazione delle liste in \texttt{C++}}
\label{code:cpp-sequence}
\begin{minted}{cpp}
std::list<int> lista;
lista.push_front(2);
lista.push_front(1);
lista.push_back(3);

Result: [1,2,3]
\end{minted}
\end{code}

\begin{code}
\captionof{listing}{Implementazione delle liste in Python}
\label{code:python-sequence}
\begin{minted}{python}
lista = ["one", "three"]
lista.insert(1, "two")

Result: [ 'one', 'two', 'three' ]
\end{minted}
\end{code}

\subsection{Insiemi}

Un insieme è una struttura dati \emph{dinamica}, \emph{non lineare} che memorizza una \emph{collezione non ordinata di elementi} senza valori ripetuti.
L'ordinamento fra elementi è dato dall'eventuale relazione d'ordine definita sul tipo degli elementi stessi.

\medskip
Le operazioni ammesse su un'insieme sono:
\begin{itemize}
	\item Operazioni di base: come inserimento, cancellazione e verifica di contenimento;
	\item Operazione di ordinamento: massimo, minimo;
	\item Operazioni insiemistiche: unione, intersezione, differenza;
	\item Iteratori: effettuare operazione per ogni elemento contenuto nell'insieme.
\end{itemize}

\input{assets/algorithms/04/set-interface}

\begin{code}
\captionof{listing}{Implementazione delle liste in Java}
\label{code:java-set}
\begin{minted}{java}
List<String> lista = new LinkedList<String>();
Set<String> docenti = new TreeSet<>();
docenti.add("Alberto");
docenti.add("Cristian");
docenti.add("Alessio");

Result: { "Alberto", "Alessio", "Cristian" }
\end{minted}
\end{code}

\begin{code}
\captionof{listing}{Implementazione delle liste in \texttt{C++}}
\label{code:cpp-set}
\begin{minted}{cpp}
std::set<std::string> frutta;
frutta.insert("mele");
frutta.insert("pere");
frutta.insert("banane");
frutta.insert("mele");
frutta.remove("mele")

Result: { "banane", "pere" }
\end{minted}
\end{code}

\begin{code}
\captionof{listing}{Implementazione delle liste in Python}
\label{code:python-set}
\begin{minted}{python}
items = { "rock", "paper", "scissors", "rock" }
print(items)
print("Spock" in items)
print("lizard" not in items)

Result: { "rock", "paper", "scissors" }
False
True
\end{minted}
\end{code}

\subsubsection{Dizionari}

Un dizionario è una struttura dati che rappresenta il concetto matematico di \emph{relazione univoca} \(R : D \to C\), o associazione chiave-valore, dove:
\begin{itemize}
	\item l'insieme \(D\) è il dominio (gli elementi sono detti \emph{chiavi});
	\item l'insieme \(C\) è il codominio (gli elementi sono detti \emph{valori}).
\end{itemize}

\medskip
Le operazioni ammesse sui dizionari sono:
\begin{itemize}
	\item Ottenere il valore associato ad una particolare chiave (se presente) o \Nil se assente
	\item inserire una nuova associazione chiave-valore, cancellando eventuali associazioni precedenti per la stessa chiave
	\item rimuovere un'associazione chiave-valore esistente
\end{itemize}

\input{assets/algorithms/04/dict-interface}

\begin{code}
\captionof{listing}{Implementazione dei dizionari in Java}
\label{code:java-liste}
\begin{minted}{java}
Map<String, String> capoluoghi = new HashMap<>();
capoluoghi.put("Toscana", "Firenze");
capoluoghi.put("Lombardia", "Milano");
capoluoghi.put("Sardegna", "Cagliari");
\end{minted}
\end{code}

\begin{code}
\captionof{listing}{Implementazione dei dizionari in \texttt{C++}}
\label{code:cpp-liste}
\begin{minted}{cpp}
std::map<std::string, int> wordcounts;
std::string s;

while (std::cin >> s && s != "end")
  ++wordcounts[s];
\end{minted}
\end{code}

\begin{code}
\captionof{listing}{Implementazione dei dizionari in Python}
\label{code:python-liste}
\begin{minted}{python}
v = {}
v[10] = 5
v["alberto"] = 42
v[10]+v["alberto"]

Result: 47
\end{minted}
\end{code}

\subsubsection{Alberi}

Un albero ordinato è dato da un insieme finito di elementi detti nodi.
Uno di questi nodi è designato come radice.
I rimanenti nodi, se esistono sono partizionati in insiemi \emph{ordinati} e \emph{disgiunti}, anch'essi alberi ordinati.

\begin{figure}[H]
	\centering
	\begin{forest} circled, wide
	[A
		[B[C]]
		[C[F][G]]
		[D[H][I]]
	]
	\end{forest}
	\caption[]{Un albero}
\end{figure}

Non vedremo implmentazione nei vari linguaggi in quanto non esiste una struttura dati definita riconosciuta universalmente.

\subsubsection{Grafi}

La struttura dati grafo è composta da:
\begin{itemize}
	\item un insieme di elementi detti nodi o vertici
	\item un insieme di coppie (ordinate oppure no) di nodi detti archi
\end{itemize}

% TODO inserire l'immagine di un grafo semplice

\medskip
Tutte le operazioni su alberi e grafi ruotano attorno alla possibilità di effettuare visite su di essi, vedremo la specifica completa più avanti.

\begin{note}
La scelta della struttura dati ha riflessi sull'efficienza e sulle operazioni ammesse.
\end{note}

\subsection{Implementazione strutture dati elementari}

\subsubsection{Lista}

Una lista è una sequenza di nodi, contenenti dati arbitrari e 1-2 puntatori all'elemento successivo e/o precedente.

\medskip
La contiguità nella lista non implica che ci sia continuità nella memoria.
Tutte le operazioni effettuate sulla lista hanno complessità \(\Omicron(1)\), ma per fare una ricerca dobbiamo spendere \(\Omicron(n)\).

\medskip
Esistono diverse implmentazioni della lista, le quali possono essere:
\begin{itemize}
	\item bidirezionale o monodirezionale;
	\item con sentinella o senza;
	\item circolare o non circolare.
\end{itemize}

% TODO inserire immagine delle liste (da fare)

\input{assets/algorithms/04/list-pseudocode}

\paragraph{Commento}
Il costo delle operazioni per questa struttura è \(\Omicron(1)\).

\begin{code}
	\captionof{listing}{Lista bidirezionale \textbf{senza} sentinella in Java}
	\label{code:java-lista-bidirezionale-sentinella}
	\javafile{assets/codes/04/List.java}
\end{code}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{assets/figures/04/forgetting}
	\caption{\texttt{xkcd no.\ 379}}
	\label{fig:forgetting}
\end{figure}

\subsubsection{Pila}

La pila è una struttura dati \emph{dinamica}, \emph{lineare} in cui l'elemento rimosso dall'operazione di cancellazione è predeterminato, ed è quello che \enquote{è rimasto per meno tempo nell'insieme} (con strategia \textsc{LIFO}).

\input{assets/algorithms/04/stack-interface}

\medskip
Ogni volta che si fa una chiamata a funzione si usa implicitamente una pila, in quanto memorizza tutti i record di attivazione delle chiamate effettuare.
Sfrutteremo questo meccanismo per visitare gli alberi, anche se non esplicitamente.

\medskip
Le pile possono essere implementate come:
\begin{itemize}
	\item liste bidirezionali, dove il puntatore punta all'elemento \textsf{top} (non utilizzate);
	\item tramite vettore, dove la dimesione è limitata quindi si crea un \foreign{overhead} più basso.
\end{itemize}

\input{assets/algorithms/04/stack-pseudocode}

\begin{code}
	\captionof{listing}{Pila basata su vettore circolare in Java}
	\label{code:vector-stack}
	\javafile{assets/codes/04/VectorStack.java}
\end{code}

\subsubsection{Coda}

La coda è una struttura dai \emph{dinamica}, \emph{lineare} in cui l'elemento rimosso dall'operazione di cancellazione è predeterminato, ed è quello che \enquote{è rimasto per più tempo nell'insieme} (con strategia, \textsc{LIFO}).

\input{assets/algorithms/04/queue-interface}

\medskip
Nei sistemi operativi, i processi in attesa di utilizzare una risorsa vengono gestiti tramite una coda.
La politica \textsc{FIFO} è onesta (\foreign{fair}) rispetto l'ordine in cui i processi sono stati inseriti.

\medskip
Le code possono essere implementate come:
\begin{itemize}
	\item liste monodirezionali, dove sono presenti due puntatori: uno alla testa (\foreign{head}) per l'estrazione, ed uno alla coda per l'inserimento;
	\item vettori circolari, il quale ha una dimensione limitata e crea un \foreign{overhead} più basso.
\end{itemize}

\input{assets/algorithms/04/queue-pseudocode}

\begin{code}
	\captionof{listing}{Pila basata su vettore in Java}
	\label{code:vector-queue}
	\javafile{assets/codes/04/VectorQueue.java}
\end{code}


\end{document}
