%&00-main.preamble

\setcounter{section}{9}
\pagestyle{footer}

% arara: pdflatex: { draft: yes, synctex: no }
% arara: pdflatex: { synctex: yes }
% arara: latexmk: { clean: partial }
\begin{document}

\section{Strutture dati speciali}

\subsection{Introduzione}

Le strutture dati che abbiamo visto fin'ora sono sequenze, insiemi e dizionari.
Se non tutte le operazioni sono necessarie, è possibile realizzare strutture dati più efficienti, \enquote{specializzate} per particolari compiti.
A volte servono operazioni speciali in quanto le operazioni di base (inserimento, cancellazione e lettura) non sono sufficienti.
Oggi ne vedremo due:
\begin{itemize}
	\item Code con priorità;
	\item Insiemi disgiunti.
\end{itemize}

\subsection{Code con priorità}

\begin{definition*}[Code con priorità]
Una coda con priorità è una struttura dati astratta, simile ad una coda, in cui ogni elemento inserito possiede una su \enquote{priorità}.
Ne esistono due versioni:
\begin{itemize}
	\item min-priority queue: dove l'estrazione avviene per valori crescenti di priorità;
	\item max-priority queue: dove l'estrazione avviene per valori decrescenti di priorità.
\end{itemize}
\end{definition*}

Le operazioni permesse sono:
\begin{itemize}
	\item l'inserimento in coda;
	\item l'estrazione dell'elemento con priorità di valore minimo/massimo;
	\item la modifica della priorità (decremento/incremento) di un elemento inserito.
\end{itemize}

\subsubsection{Specifica}

\begin{algorithm}[H]
	\caption{Specifica \textsc{Priority Queue}}
	\input{assets/algorithms/10/heap-interface}
\end{algorithm}

Nelle prossime lezioni utilizzeremo questa struttura nei seguenti algoritmi:
\begin{itemize}
	\item Algoritmo di Dijkstra;
	\item Codifica di Huffman;
	\item Algoritmo di Prim per alberi di copertura di peso minimo.
\end{itemize}

\begin{table}[H]
	\centering
	\caption{Implementazioni e relative complessità delle operazioni}
	\begin{tabular}{@{} *{6}{l} @{}}
	\toprule
		& \minFunction & \heapDeleteMin & \heapInsert & \heapDecrease\\
	\cmidrule{2-5}
		Lista/vettore non ordinata & \(\Omicron(n)\) & \(\Omicron(n)\) & \(\Omicron(n)\) & \(\Omicron(n)\)\\
	\addlinespace
		Lista ordinata & \(\Omicron(1)\) & \(\Omicron(1)\) & \(\Omicron(n)\) & \(\Omicron(n)\)\\
	\addlinespace
		Vettore ordinato & \(\Omicron(1)\) & \(\Omicron(n)\) & \(\Omicron(n)\) & \(\Omicron(\log n)\)\\
	\addlinespace
		Alberi bilanciati & \(\Omicron(\log n)\) & \(\Omicron(\log n)\) & \(\Omicron(\log n)\) & \(\Omicron(\log n)\) \\
	\bottomrule
	\end{tabular}
\end{table}

L'Heap è una struttura dati speciale che associa:
\begin{itemize}
	\item i vantaggi di un albero, ossia l'esecuzione in tempo \(\Omicron(\log n)\);
	\item i vantaggi di un vettore, la memorizzazione efficiente.
\end{itemize}

Nello studiare la struttura dati Heap seguiremo l'approccio storico, vedremo quindi prima l'algoritmo \heapSort e poi studieremo le code con priorità.

\subsubsection*{Albero binario heap}

\begin{definition}[Albero max-heap]
Un albero binario completo è un albero max-heap se e solo se il valore memorizzato in un nodo è maggiore dei valori memorizzati nei suoi figli.
\end{definition}

\begin{definition}[Albero min-heap]
Un albero binario completo è un albero max-heap se e solo se il valore memorizzato in un nodo è minore dei valori memorizzati nei suoi figli.
\end{definition}

\begin{note}
Le definizioni e gli algoritmi per gli alberi max-heap sono simmetrici rispetto agli algoritmi per gli alberi min-heap.
\end{note}

Un albero heap \emph{non impone} una relazione di ordinamento totale fra i figli di un nodo, ma un'ordinamento parziale.
Il quale è:
\begin{itemize}
	\item \(riflessivo\): ogni nodo è \(\geqslant\) di se stesso
	\item \(antisimmetrico\):
	\item \(transitivo\):
\end{itemize}

L'ordinamento parziale è una nozione più debole di un ordinamento totale, ma è più semplice da costruire.

\subsubsection{Vettore heap}

Un albero binario può essere rappresentato tramite un vettore heap.


\begin{property*}[max-heap su vettore]
\(A[i] \geqslant A[l(i)], A[i] \geqslant A[r(i)]\)
\end{property*}

\maxHeapify è la procedura che permette di ripristinare la proprietà di max-heap di un vettore

\begin{property*}[min-heap su vettore]
\(A[i] \leqslant A[l(i)], A[i] \leqslant A[r(i)]\)
\end{property*}

\minHeapify è la procedura che permette di ripristinare la proprietà di min-heap di un vettore

\heapSort è composta da tre funzioni:
\begin{itemize}
	\item \maxHeapify la quale ripristina la proprietà max-heap;
	\item \heapBuild la quale costruisce un max-heap a partire da un vettore non ordinato;
	\item \minHeapify che ordina un max-heap \enquote{in-place}.
\end{itemize}

\end{document}
\subsubsection{Introduzione}
\subsubsection{HeapSort}
\subsubsection{Implementazione code}

\subsection{Insiemi disgiunti}

\subsubsection{Introduzione}
\subsubsection{Realizzazione basata su liste}
\subsubsection{Realizzazione basata su alberi}
\subsubsection{Euristiche}
