\documentclass[00-main.tex]{subfiles}
% \standalonetrue
\setcounter{section}{4}
\pagestyle{footer}

\title{Alberi}

% arara: pdflatex: { draft: yes, synctex: no }
% arara: pdflatex: { synctex: yes }
% arara: latexmk: { clean: partial }
\begin{document}
% \maketitle

\section{Alberi}

% TODO scrivere introduzione

\subsubsection{Definizioni}

\begin{definition}[Albero radicato -- \foreign{rooted tree}]
Un albero consiste di un insieme di nomi e un insieme di archi orientati che connettono coppie di nodi, con le seguenti proprietà:
\begin{itemize}
	\item un nodo dell'albero è designato come nodo radice;
	\item ogni nodo \(n\), a parte la radice, ha esattamente un arco entrante;
	\item esiste un cammino unico dalla radice ad ogni nodo;
	\item l'albero è connesso.
\end{itemize}
\end{definition}

\begin{definition}[Albero radicato, definizione ricorsiva]
Un albero è dato da:
\begin{itemize}
	\item un insieme vuoto, oppure
	\item una radice e zero o più sottoalberi, ognuno dei quali è albero; la radice è connessa alla radice di ogni sottoalbero con un arco orientato.
\end{itemize}
\end{definition}

\begin{definition}[Profondità -- \foreign{depth}]
La lunghezza del cammino semplice dalla radice al nodo (misurato in archi).
\end{definition}

\begin{definition}[Livello -- \foreign{level}]
L'insieme dei nodi alla stessa profondità.
\end{definition}

\begin{definition}[Altezza dell'albero -- \foreign{height}]
La profondità massima delle sue foglie.
\end{definition}

\subsection{Terminologia}

\begin{minipage}{.5\textwidth}
\centering
	\begin{itemize}
		\item \(A\) è la radice (\foreign{root});
		\item \(B\), \(C\) sono radici dei sottoalberi (\foreign{roots of their subtrees});
		\item \(D\), \(E\) sono fratelli (\foreign{siblings});
		\item \(D\), \(E\) sono figli (\foreign{children}) di \(B\);
		\item \(B\) è il padre (\foreign{parent}) di \(D\), \(E\);
		\item \(H\), \(I\), \(J\), \(K\), \(L\), \(M\), \(G\) sono foglie (\foreign{leafs});
		\item gli altri nodi sono nodi interni (\foreign{internal nodes});
		\item \(E\) è lo zio di \(I\);
		\item \(B\) è il nonno di \(I\);
		\item \(A\) è il bis-nonno di \(I\).
	\end{itemize}
\end{minipage}
\begin{minipage}{.5\textwidth}
\centering
	\begin{forest}
		,circled, wide
		[A
			[B
				[D
					[H]
					[I]
				]
				[E
					[J]
					[K]
				]
			]
			[C
				[F
					[L]
					[M]
				]
				[G]
			]
		]
	\end{forest}
\end{minipage}

\subsection{Alberi binari}

\begin{definition}[Albero binario]
Un albero binario è un albero radicato in cui ogni nodo ha al massimo due figli, che vengono identificati come figlio sinistro e figlio destro.
\end{definition}

\begin{note}
Due alberi \(T\) e \(U\) che hanno gli stessi nodi, gli stessi figli per ogni nodo e la stessa radice, sono distinti qualora un nodo \(u\) sia designato come figlio sinistro di un nodo \(v\) in \(T\) e come figlio destro del medesimo nodo in \(U\).
In altre parole, anche se due alberi hanno lo stesso numero di nodi ed ognuno di questi nodi ha lo stesso numero di figli non è che detto che l'albero risultante sia identico.
\end{note}

\includestandalone{assets/algorithms/05/tree-interface}

\subsubsection{Memorizzazione di un albero binario}

\begin{figure}[H]
	\centering
	\input{assets/figures/05/binary-tree}
\end{figure}

Vengono memorizzati i seguenti campi:
\begin{itemize}
	\item \emph{parent}: riferimento al nodo padre;
	\item \emph{left}: riferimento al figlio sinistro;
	\item \emph{right}: riferimento al figlio destro.
\end{itemize}
Uno qualunque di questi oggetti potrebbe essere pari a \Nil, stando ad indicare che sotto di sé non esiste nessun sottoalbero.

\subsubsection{Implementazione}

% TODO Implementazione binary tree in pseudocodice
\includestandalone{assets/algorithms/05/tree-pseudocode}

\subsubsection{Visite}

La visita di un albero (o la ricerca) è una strategia per passare attraverso (visitare) tutti i nodi di un albero.
Si possono distinguere due tipi di visite:
\begin{enumerate}
	\item visita in profondità: chiamata anche \foreign{Deep-First Search} (DFS), per visitare un albero visita ricorsivamente ognuno dei suoi sottoalberi; esistono tre varianti in base a quando il nodo viene visitato (in pre, in o post order); questa particolare visita richiede il meccanismo di una pila (\foreign{stack});
	\item visita in ampiezza: chiamata anche \foreign{Breadth First Search} (BFS), per visitare un albero visita ogni livello, uno dopo l'altro partendo dalla radice; richiede il meccanismo di una coda (\foreign{queue}).
\end{enumerate}

A seconda di dove scrivo il codice in questo schema ottengo una visita diversa.

\includestandalone{assets/algorithms/05/dfsSchema}

\subsubsection{Applicazioni}

In genere post-visita e in-visita sono quelle più applicate, la pre-visita meno.

\subsubsection{Visita in post-ordine}

Una possibile applicazione della visita post-ordine è quella di effettuare un conteggio dei nodi presenti nell'albero.

\includestandalone{assets/algorithms/05/conteggioNodi}

\subsubsection{Visita in ordine (in-visita)}

\includestandalone{assets/algorithms/05/stampaEspressioni}

% \subsection{Alberi generici}
%
% \subsubsection{Visite}
%
% \subsubsection{Implementazione}

\end{document}
