\documentclass[main.tex]{subfiles}
%&../../preamble.main

\setcounter{chapter}{18}

% arara: pdflatex: { draft: yes, synctex: no }
% arara: pdflatex: { synctex: yes }
\begin{document}
\chapter{Soluzioni per problemi intrattabili}

\section{Algoritmi pseudo-polinomiali}

\subsection{Somma di sottoinsieme}

\paragraph{Definizione del problema}
Dati un insieme \(A = \{a_1, a_2, \dots, a_n\}\) di interi positivi e un intero positivo \(k\), esiste un sottoinsieme \(S\) di indici in \(1, \dots, n\) tale che \(\sum_{i \in S}^{a_i} = k\) ?

\paragraph{Definizione equazione di ricorrenza}

Definiamo una tabella booleana \(DP[0 \dots n][0 \dots k]\).
\(DP[i][r]\) è uguale a \True se e solo se è possibile ottenere \(r\) dai primi \(i\) valori memorizzati nel vettore di input.
\[
	DP[i][r] =
	\begin{dcases}
		\False & r < 0 \\
		\True & r = 0 \\
		\False & r > 0 \land i = 0 \\
		DP[i - 1][r]\text{ \Or }DP[i - 1][r - A[i]]& r > 0 \land i > 0 \\
	\end{dcases}
\]

Essendo un problema decisionale, è possibile semplificare e utilizzare spazio \(\Theta(k)\) invece che \(\Theta(nk)\), in quanto avrò \(n\) righe e \(k\) colonne.

\paragraph{Algoritmo}

L'algoritmo sfrutta l'equazione di ricorrenza

\begin{algorithm}[H]
	\caption{Somma di sottoinsiemi}
	\input{subSetSum}
\end{algorithm}

\paragraph{Analisi della complessità}
La complessità dell'algoritmo è \(\Omicron(nk)\), ma la complessità dei dati in ingresso è \(\Omicron(n \log k)\) in quanto i valori più grandi del nostro obiettivo possono essere esclusi.
Se \(k\) è \(\Omicron(n^c)\) con \(c\) costante, allora \subSetSum ha complessità polinomiale \(\Omicron(n^{c+1})\).
Ma se \(k\) è  \(\Omicron(2^n)\), allora \subSetSum ha complessità superpolinomiale \(\Omicron(n \cdot 2^{n})\).

\begin{observation}
La complessità di \subSetSum dipende quindi dai valori contenuti nell'insieme, e non soltanto dalla cardinalità dei dati in ingresso (\(n\)).
\end{observation}

\begin{definition}[problema fortemente \NP-completo]
Sia \(R_p\) il problema \(R\) ristretto a quei dati d'ingresso per i quali il più grande valore da rappresentare è limitato superiormente da \(p(d)\), con \(p\) funzione polinomiale in \(d\).
R è \alert{fortemente \NP-completo} se \(R_p\) è \NP-completo.
\end{definition}

Il problema cricca (\clique), ad esempio, è fortemente \NP-completo, mentre \subSetSum non lo è.

\begin{definition}[problema debolmente \NP-completo]
Se un problema \NP-completo non è fortemente \NP-completo, allora è \alert{debolmente \NP-completo}.
\end{definition}

\begin{note}
Il problema di \subSetSum è debolmente \NP-completo, in quanto limitando le dimensioni dei dati in ingresso il problema diventa polinomiale.
\end{note}

\subsection{Partizione}
\SetKwFunction{partition}{partizione}
\SetKwFunction{partitionThree}{partizioneTerne}

\paragraph{Definizione del problema}
Dato un insieme \(A = \{a_1, a_2, \dots, a_n\}\) di interi positivi, trovare un sottoinsieme \(S\) di \(1, \dots, n\) tale che \(\sum_{i \in S} a_i = \sum_{i \not\in S} a_i\).

% TODO figura
\texttt{MATERIALE MANCANTE}

\paragraph{Considerazioni}
L'algoritmo \partition è debolmente \NP-completo perché è possibile ridurlo a \subSetSum scegliendo come valore \(k\) la metà di tutti i valori scelti.

% TODO formula
\texttt{MATERIALE MANCANTE}

\subsection{Partizione di terne}

\paragraph{Definizione del problema}
Dati \(3n\) interi \(\{a_1, a_2, \dots, a_n\}\), trovare una partizione di \(n\) triple \(T_1, \dots, T_n\) tale che la somma dei tre elementi di ogni \(T_j\) sia la stessa, per \(1 \leqslant j \leqslant n\).

\texttt{MATERIALE MANCANTE}
% TODO 3 7 2 / 10 1 1

\paragraph{Considerazioni}
L'algoritmo \partitionThree è fortemente \NP-completo, in quanto non esiste un algoritmo pseudo-polinomiale per risolvere questo problema.

\section{Algoritmi di approssimazione}

% TODO copiare testo

\begin{note}
\texttt{MATERIALE MANCANTE}
% TODO copiare nota
\end{note}

\subsection{Bin packing}

\paragraph{Definizione del problema}
% TODO ricopiare testo
\texttt{MATERIALE MANCANTE}

Utilizziamo un approccio ingordo.

Se consideriamo gli oggetti in ordine non descrescente.

\subsection{Commesso viaggiatore}
\texttt{MATERIALE MANCANTE}

\paragraph{Definizione del problema}
% TODO ricopiare testo
\texttt{MATERIALE MANCANTE}

\paragraph{Restringiamo il problema}
\texttt{MATERIALE MANCANTE}

\begin{theorem}[tsp non  approssimabile]
\texttt{MATERIALE MANCANTE}
\end{theorem}

\begin{note}
\(\Delta-tsp\) è un problema approssimabile, ma il problema generale no.
\end{note}

\section{Algoritmi branch\&bound}

Variante della tecnica di programmazione backtrack.
Cerchiamo di analizare tutto lo spazio delle soluzioni, evitando certe sequence di scelte che facciano diminuire il costo della soluzione parziale costruita.

Cerchiamo i limiti (superiore ed inferiore) della soluzione minima.

\begin{figure}[H]
	\centering
	\includestandalone{assets/figures/19/branchAndBound-1}
	\caption{Se \textsf{lb}(\(S\),\(i\)) è maggiore o uguale a \(minCost\), allora si può evitare di generare ed esplorare il sottoalbero delle scelte radicato in tal nodo.}
	% \label{}
\end{figure}

Questo metodo non migliora la complessità (superpolinomiale) della procedura \enumeration, ma nella pratica ne abbassa di molto il tempo di esecuzione.
Tutto dipende dalla funzione \lowerBound, che deve essere il più possibile vicino alla soluzione ottima.
Il limite superiore è dato dal \(minCost\).

\begin{algorithm}[H]
	\caption{Somma di sottoinsiemi}
	\input{branchAndBound}
\end{algorithm}

\paragraph{Problema del commesso viaggiatore}
Applichiamo questo ragionamento al problema del commesso viaggiatore.
Sia \(n\) il numero delle città, e \(d[h][k]\) la distanza, intera e non negativa, fra le città \(h\) e \(k\).
Al passo \(i\)-esimo sono state fatte le scelte \(S[1][i]\) prese dall'insieme \(1, \dots, n\).
Un percorso ammissible che \enquote{espande} \(S[1][i]\) deve
\begin{enumerate*}[label=\arabic*)]
	\item attraversare le città \(S[1][i]\);
	\item passare da \(S[i]\) ad una qualsiasi delle rimanenti \(n-1\) città;
	\item attraversare queste ultime città in un ordine qualsiasi;
	\item da una di queste ritornare a \(S[1]\).
\end{enumerate*}

Facciamoci un po' di calcoli:
\(C[i]\) è il costo che ho sostenuto per fare i primi \(i\) passi.
\begin{equation*}
	C[i] =
	\begin{dcases}
		0 & i = 1 \\
		C[i-1] + d[ S[i-1] ][ S[i] ] & i > 1 \\
	\end{dcases}
\end{equation*}

Il limite inferiore (\foreign{lower bound}) della distanza per tornare a \(S[1]\) (\(O(n)\)):
\[A = \min_{h \notin S} \{ d[S[h][1] \}\]

Il limite inferiore (\foreign{lower bound}) della distanza per andarsene da \(S[i]\) (\(O(n)\)):
\[B = \min_{h \notin S}\{d[S[i], h] \}\]

Lower bound della distanza percorsa per attraversare una qualsiasi di queste ultime \(n - i\) città, provenendo da (e dirigendosi verso) un'altra di queste \(n - i\) città (\(O(n^3)\))
\[D[h] = \min_{p,q}\{d[p, h] + d[h, q] \colon h \Neq p \Neq q \},\;\]

Un lower bound \(\lowerBound(S)\) è dato dalla seguente espressione:
\[
\lowerBound(s,i) =
	\begin{cases}
		C[i] + d[S[i], S[1]] & i=n \\
		C[i] + A + B + \left\lceil (\sum_{h \notin S} D[h])/2\right\rceil & i < n
	\end{cases}
\]

\begin{algorithm}[H]
	\caption{Appoccio branch\&bound al problema del commesso viaggiatore}
	\input{bbTsp}
\end{algorithm}

\begin{figure}[H]
	\centering
	\includestandalone[width=\textwidth]{assets/figures/19/branchAndBound-2}
	\caption{inserisci didascalia}
\end{figure}

\clearpage
\section{Algoritmi euristici}

Si può ricorrere ad algoritmi \enquote{euristici} che forniscono una soluzione ammissibile, non necessariamente ottima né approssimata.
Possiamo utilizzare le tecniche di programmazione per algoritmi ingordi o di ricerca locale.

\paragraph{Shortest edges first}
Cambiamo approccio per il problema del commesso viaggiatore.
Ordiniamo gli archi per pesi non decrescenti e aggiungiamo archi alla soluzioni seguendo questo ordine finché non sono stati aggiunti \(n-1\) archi, dove \(n\) è il numero di nodi.
Però, attenzione, per poter aggiungere un arco, occorre verificare che:
\begin{enumerate*}[label={\arabic*)}]
	\item per ciascuno dei suoi nodi non siano stati già scelti due archi;
    \item che non si formino circuiti (\mfSet);
\end{enumerate*}
A questo punto, si è trovata una catena Hamiltoniana e si chiude il circuito aggiungendo l'arco tra i due nodi estremi della catena.

% TODO figure

\begin{algorithm}[H]
	\caption{Approccio ingordo al problema del commesso viaggiatore}
	\input{greedyTsp}
\end{algorithm}

\subparagraph{Analisi della complessità}
L'algoritmo costa \(\Omicron(n^2 \log n)\) a causa dell'\emph{ordinamento degli archi}.

La soluzione ottenuta può essere la base di partenza per un algoritmo \branchAndBound che può essere migliorata tramite ricerca locale.

\paragraph{Approccio Nearest neighbor}
Si parte da una città e si seleziona come prossima città quella più vicina.
Si va avanti così, evitando città già visitate.
Quando si sono visitate tutte le città si torna alla città di partenza.

\subparagraph{Analisi della complessità}
Questo algortimo ha complessità \(\Omicron(n^2)\) perché per ogni città devo guardare tutte le altre.

% TODO figura

\end{document}
