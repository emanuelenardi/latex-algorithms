%&../preamble

% arara: pdflatex: { synctex: no }
% arara: latexmk: { clean: partial }
\ifstandalone
\begin{document}
\begin{algorithm}[H]
\fi

\prototype{\prim{\Graph \(G\), \Node \(r\), \Array{\Int} \(p\)}}{
	\params{prim}{r}[nodo dalla quale parto, la radice]
	\params{prim}{p}[vettore dei padri]

	\BlankLine
	\Heap \(Q\) \Assign \minHeapConstructor\;
	\PriorityItem{} \(\pos\)  \Assign \new \PriorityItem{1\dots G.\(n\)}\;

	\BlankLine
	\tcp{per ciascun nodo appartenente al grafo, esclusa la radice che ne fa già parte}
	\tcp{inserisco i nodi nella coda, memorizzando la loro posizione}
	\lnlset{prim:init}{1}%
	\ForEach{\(u \in G.\VV - \{ r \}\)}{

		\BlankLine
		\(\pos[u] \Assign Q.\heapInsert(u, +\infty)\) \tcp{\(+\infty\) indica che devono ancora essere raggiunti}
	}

	\BlankLine
	\tcp{inserisco il "nodo di partenza"}
	\(\Pos[r] \Assign Q.\heapInsert{r, 0}\)\;
	\(p[r] \Assign 0\) \Comment*[l]{convenzione per indicare che non ha padre}

	\BlankLine
	\lnlset{prim:ciclo-esterno}{2}%
	\While(\Comment*[h]{non ci sono più nodi}){\Not \(Q\).\setEmpty}{

	\BlankLine
		\Node \(u\) \Assign \(Q\).\heapDeleteMin \Comment*[l]{cancello e restituisco il nodo}
		\(\Pos[u] \Assign \Nil\) \Comment*[h]{non considero più quel nodo}\;

		\BlankLine
		\tcp{per ciascun nodo adiacente}
		\lnlset{prim:ciclo-interno}{3}%
		\ForEach{\(v \in G.\adj(u)\)}{

			\BlankLine
			\If{\(\Pos[v] \Neq \Nil\) \And \(\weight{u,v} < \Pos[v].\priority\)}{
				\params{prim-cycle}{\Pos[v] \Neq \Nil}[è già stato visitato]
				\params{prim-cycle}{\weight{u,v} < \Pos[v].\priority}[il peso del lato è minore della priorità del nodo]

				\BlankLine
				\BlankLine
				\(Q.\heapDecrease{\(\Pos[v]\), \(\weight{u,v}\)}\) \tcp{decremento la priorità del nodo}
				\(p[v] \Assign u\) \tcp{il padre di \(v\) diventa \(u\)}
			}
		}
	}
}

\ifstandalone
\end{algorithm}
\end{document}
\fi
