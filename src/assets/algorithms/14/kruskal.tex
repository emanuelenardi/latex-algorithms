%&../preamble

% arara: pdflatex: { synctex: no }
% arara: latexmk: { clean: partial }
\ifstandalone
\begin{document}
\begin{algorithm}[H]
\fi

\prototype{\Set \kruskal{\Edge{} \(A\), \Int \(n\), \Int \(m\)}}{
	\params{A}[vettore di archi]
	\params{n}[numero di archi]
	\params{m}[numero di archi]

	\BlankLine
	\BlankLine
	\lnl{kruskal:init}%
	\Set \(T\) \Assign \setConstructor \tcp{insieme (inizialmente vuoto) che conterrà gli archi dell'albero minimo}
	\mfSet \(M\) \Assign \mfConstructor{n} \tcp{insieme disgiunto grande }

	\BlankLine
	\tcp{ordina gli archi per peso crescente}
	\lnl{kruskal:order}%
	\{ ordina \(A[1, \dots, m]\) in modo che \(A[1].\peso \leqslant \cdots \leqslant A[m].\peso\) \}\;
%
	\BlankLine
	\Int \(\Count \Assign 0\) \tcp{tiene conto del numero di archi aggiunti}
	\Int \(i \Assign 1\) \tcp{punta all'arco corrente}

	\BlankLine
	\tcp{il ciclo termina quando l'albero è costruito}
	\lnl{kruskal:op}%
	\While{\(\Count < n-1\) \And \(i \leqslant m\)}{
		\params{c < n-1}[ho raggiunto tutti gli archi necessari per fare un albero]
		\params{i \leqslant m}[ho esaurito tutti gli archi da guardare (per controllo)]

		\BlankLine
		\BlankLine
		\If(\Comment*[h]{non fanno parte dello stesso albero}){\(M.\mfFind{\(A[i].u\)} \Neq M.\mfFind{\(A[i].v\)}\)}{

			\BlankLine
			\(M.\mfMerge{\(A[i].u\), \(A[i].v\)}\) \tcp{unisco gli insiemi disgiunti}
			\(T.\setInsert{\(A[i]\)}\) \tcp{inserisco l'arco all'albero}
			\(\Increment{c}\) \tcp{ho aggiunto un altro arco}
		}

		\BlankLine
		\(\Increment{i}\) \tcp{punta all'arco successivo}
	}

	\BlankLine
	\tcp{restituisco l'albero di copertura minimo}
	\Return \(T\)\;
}

\ifstandalone
\end{algorithm}
\end{document}
\fi
