%&../preamble

% arara: pdflatex: { synctex: no }
% arara: latexmk: { clean: partial }
\ifstandalone
\begin{document}
\begin{algorithm}[H]
\fi

\BlankLine
\tcp{effettua l'ordinamento dei sotto-vettori}
\prototype{\merge{\Item \(A\), \Int \(first\), \Int \(last\), \Int \(mid\)}}{

	\BlankLine
	\Int \(i\), \(j\), \(k\), \(h\)\;

	\BlankLine
	\tcp{inizializzo i puntatori}
	\(i \Assign first\)\;
	\(j \Assign mid+1\)\;
	\(k \Assign first\)\tcp*[l]{\(k\): indica la prossima posizione di scrittura}

	\BlankLine
	% \tcp{}
	\While{\(i \leqslant mid\) \And \(j \leqslant last\)}{

		\BlankLine
		\tcp{B è il vettore di appoggio in cui memorizzo la porzione di vettore già ordinata}
		\eIf{\(A[i] \leqslant A[j]\)}{
			\tcp{l'elemento è gia ordinato}
			\(B[k] \Assign A[i]\)\tcp*[l]{copio l'elemento del vettore di sinistra}
			\Increment{i}\tcp*[l]{scorro l'indice nel vettore di sinistra}
		}{
			\(B[k] \Assign A[j]\)\tcp*[l]{copio l'elemento del vettore di destra}
			\Increment{j}\tcp*[l]{scorro l'indice nel vettore di destra}
		}

		\BlankLine
		\tcp{\emph{in entrambi i casi} ho inserito un valore}
		\Increment{k}\;
	}

	\BlankLine
	\tcp{se uno dei due vettori finisce ricopio la parte ordinata alla fine del vettore d'appoggio}
	\(j \Assign last\)\;
	\From{\(h \Assign mid\) \DownTo \(i\)}{
		\(A[j] \Assign A[h]\)\;
		\Decrement{j}\;
	}

	\BlankLine
	\tcp{ricopio il vettore d'appoggio del vettore originale}
	\From{\(j \Assign first\) \DownTo \(k-1\)}{
		\(A[j] \Assign B[j]\)\;
	}
}

\ifstandalone
\end{algorithm}
\end{document}
\fi
