\documentclass[00-main.tex]{subfiles}
\standalonetrue
\setcounter{section}{12}
\pagestyle{footer}

% arara: pdflatex: { synctex: yes }
% arara: latexmk: { clean: partial }
\begin{document}
\section{Programmazione Dinamica}

% TODO schema riassiuntivo

La \emph{programmazione dinamica} è caratterizzata da 4 fasi principali:

\begin{enumerate}
	\item caratterizzare \emph{matematicamente} la struttura di una soluzione ottima;
	\item definire ricorsivamente il valore di una soluzione ottima;
	\item calcolare il valore di una soluzione ottima con approccio bottom-up
		\begin{itemize}
			\item utilizzando quindi una tabella per memorizzare la soluzione dei sottoproblemi  ed utilizzarla per evitare di ripetere i calcoli più volte.
		\end{itemize}
	\item Ricostruire la soluzione ottima.
\end{enumerate}

\subsection{Numeri di fibonacci}

\includestandalone{assets/algorithms/13/fibonacci-recursive}
\[
	T(n) =
	\begin{cases}
		1					& n \leqslant 1 \\
		T(n-1) + T(n-2) + 1	& n > 1 \\
	\end{cases}
\]
\paragraph{Complessità} \'E una ricorrenza lineare di ordine costante:

\begin{itemize}
	\item \(a_1 = 1, a_2 = 1, a = a_1 + a_2 = 2, \beta=0\)
	\item Complessità: \(\Theta(a^n \cdot n^\beta) = \Theta(2^n)\)
\end{itemize}

% L'albero di ricorsione del problema domino è il seguente:
% TODO albero di ricorsione del problema domino

Dall'albero di ricorsione possiamo notare che molti sottoproblemi vengono ripetuti.

\subsubsection{Come evitare di risolvere un problema più di una volta}

Quando risolviamo un (sotto)problema, memorizziamo il risultato che otteniamo in una tabella (che può essere implementata come un vettore, una matrice, un dizionario\dots).
La tabella dovrà contenere un elemento per ogni sottoproblema che dobbiamo risolvere.
I casi base possono essere memorizzati nelle posizioni relative.
Dopodiché l'iterazione è bottom-up, ovvero si parte dai casi base e si va verso problemi via via sempre più grande.

% TODO mettere una di fianco all'altra

% TODO aggiungere tabella
\includestandalone{assets/algorithms/13/fibonacci-iterative}

\paragraph{Analisi delle complessità}
La complessità in tempo è lineare, come la complessità spaziale.

% TODO dividi qui

Possiamo ridurre lo spazio utilizzato.

% TODO aggiungere tabella
\includestandalone{assets/algorithms/13/fibonacci-space-optimize}

\paragraph{Analisi della complessità}
Questa implementazione ha costo costante nello spazio.


\begin{center}
	\begin{tabular}{@{} !l ^c ^c @{}}\toprule
		\multirow{2}{*}{Funzione} & \multicolumn{2}{c}{Complessità} \\\cmidrule{2-3}
		& tempo & spazio \\\midrule
		ricorsiva & \(\Omicron(n2^n)\) & \(\Omicron(n^2)\) \\\lightrule
		iterativa & \(\Omicron(n^2)\)  & \(\Omicron(n^2)\) \\\lightrule
		finale & \(\Omicron(n^2)\)  & \(\Omicron(n)\)   \\\bottomrule
	\end{tabular}
\end{center}

\subsection{Hateville}

% TODO rimando al foglio con tutti i problemi
Questo problema è stato presentato la prima volta nel compito del % TODO trovare data

% TODO scrivere dimostrazione della sottostruttura ottima
% NB guardarla sugli appunti

% \begin{enumerate}
% 	\item
% 	\item
% 	\item
% \end{enumerate}

\begin{equation*}
HV(i) =
\begin{dcases}
	0 & i = 0 \\
	\{1\} & i = 1 \\
	highest(HV(i-1), HV(i-2) \cup \{i\}) & i \geqslant 2 \\
\end{dcases}
\end{equation*}

\begin{equation*}
HV(i) =
\begin{dcases}
	0 & i = 0 \\
	\{1\} & i = 1 \\
	max(DP(i-1), DP(i-2) \cup \{i\}) & i \geqslant 2 \\
\end{dcases}
\end{equation*}

\subsubsection{Soluzione con linguaggi di programmazione}

\begin{comment}
\begin{minted}{java}
public int hateville(int[] D, int n) {
	int[] DP = new int[n+1];
	DP[0] = 0;
	DP[1] = D[0];
	for (int i=2; i <= n; i++) {
		DP[i] = max(DP[i-1],DP[i-2]+D[i-1]);
	}
	return DP[n];
}
\end{minted}

\begin{minted}{python}
def hateville(D):
	DP = [ 0, D[0] ]

	for i in range(1,len(D)):
		DP.append( max(DP[-1], DP[-2] + D[i]) )

	return DP[-1]
\end{minted}
\end{comment}

% TODO importare codice con solution

\paragraph{Analisi della complessità}


% \begin{note}
% Non è possibile migliorare la complessità spaziale di \hateville poiché è necessario ricostruire la soluzione.
% \end{note}

\subsection{Zaino}

% TODO tovare esemi
% \'E possibile ritrovare questo problema negli esami del

% TODO copiare definizione
\paragraph{Definizione informale del problema}

% TODO copiare definizione
\paragraph{Definizione formale del problema}

% \includestandalone{assets/algorithms/13/knapsack-dp}

% TODO scrivere algoritmo
% \includestandalone{assets/algorithms/13/knapsack-recursive}

\paragraph{Analisi della complessità}
Non si può fare meglio di così.

\begin{observation}
Non tutti gli elementi della matrice sono necessari alla risoluzione del nostro problema.
\end{observation}

Ad esempio

\begin{note}
Questo ci porta ad una nuova tecnica.
\end{note}

\subsection{Memoization}

La \emph{memoization} (annotazione) è una tecnica che fonde l'approccio di \emph{memorizzazione} della programmazione dinamica con l'approccio \emph{top-down} di divide-et-impera.

Quando devo risolvere un sottoproblema controllo prima se l'ho già risolto guardando nella cella corrispondente della tabella dove memorizzo i risultati, altrimenti lo calcolo on-the-fly (al momento) chiamando ricorsivamente i sottoproblemi e scrivo i rispettivi risultati nella tabella.

In questo modo mi assicuro di fare il calcolo una ed una volta sola ed evito di calcolare valori che non verranno mai usati.

% \includestandalone{assets/algorithms/13/knapsack-memo}
% TODO babel
\newcommand\foreign[1]{\emph{#1}}
La tabella viene inizializzata esternamente, nella funzione \foreign{wrapper}, con un valore che non viene usato durante la procedura (\(-1\) nel caso vengano usati \emph{solo} valori positivi, \(-\infty\) nel caso vengano usati sia valori positivi che valori negativi)

% zaino con memoization
% TODO inserire codice
% \begin{minted}{python}
%
% \end{minted}

% NOTE con -1 sono indicate i valori che non vengono calcolati

\paragraph{Scelta della struttura dati}
\'E meglio scegliere una tabella o un dizionario?

Il costo di esecuzione è \(\Omicron(min(2^n, nC))\).

\begin{comment}
% zaino con dizionario
% TODO inserire didascalia
\begin{minted}{python}
def knapsack(w,p,C):
	DP = {} # Hash-table dictionary
	return knapsackRec(w, p, len(w), C, DP)

def knapsackRec(w, p, i, c, DP):
	if c < 0:
		return -math.inf
	if i == 0 or c == 0:
		return 0
	if (i,c) not in DP:
		if w[i-1] <= c:
			taken = knapsackRec(w,p,DP,i-1,c-w[i-1]) + p[i-1]
		else:
			taken = -math.inf
			DP[i,c] = max(nottaken, taken)
			return DP[i,c]
\end{minted}

% annotazione automatica in Python
\begin{minted}{python}
from functools import wraps

def memo(func):
	cache = {}
	@wraps(func)
	def wrap(*args):
		if args not in cache:
			cache[args] = func(*args)
		return cache[args]
	return wrap

@memo
def knapsackRec(w, p, i, c):

	if c < 0:
		return -math.inf

	if i == 0 or c == 0:
		return 0

	nottaken = knapsackRec(w,p,i-1,c)
	taken = knapsackRec(w,p,i-1,c-w[i-1])+p[i-1]
	return max(nottaken, taken)

def knapsack(w,p,C):
	return knapsackRec(w,p,len(w),C)
\end{minted}
\end{comment}

\begin{note}
La ricostruzione della soluzione è lasciata come esercizio.
\end{note}

\subsection{Zaino senza limiti (nella scleta degli oggetti)}

% TODO copiare definizione
\paragraph{Definizione informale del problema}

% \includestandalone{assets/algorithms/13/knapsack-limitless-memo}

% TODO commentare funzione
% Mi conviene memorizzare dove si trova il massimo.

% \includestandalone{assets/algorithms/13/knapsack-limitless-memo-max}

\begin{itemize}
	\item \(c \Equal 0\)
	\item \(\ArrayCall{pos}{c} < 0\)
\end{itemize}

\paragraph{Analisi della complessità}
Ognuno degli elementi costa \(\Theta(n)\) per essere riempito, mal che vada devo riempire tutte le \(C\) caselle delle tabelle.
Quindi nel caso pessimo ho una complessità di \(\Omicron(nC)\)

\subsection{Sottosequenza comune massimale}

% TODO trovare l'esame
% Questo problema è stato affrontato in modo \emph{molto} approfondito nella soluzione dell'esame del

\begin{comment}
\begin{definition}[sottosequenza]

\end{definition}

\begin{definition}[sottosequenza comune]

\end{definition}

\begin{definition}[sottosequenza comune massimale]

\end{definition}
\end{comment}

\paragraph{Defizione formale del problema}
Date due sequenze \(P\) e \(T\) di lunghezza \(n\) e \(m\), rispettivamente, trovare la più lunga sottosequenza comune di \(P\) e \(T\).

Una soluzione banale è quella di cercare tutte le sottosequenze e di prendere quella di lunghezza maggiore.

La quale ha una complessità che non vogliamo apgare inq uanto ci sono soluzioni più efficienti.

\subsubsection{Descrizione matematica della soluzione ottima}

% TODO continua

\subsection{String matching approssimato}

\begin{itemize}
	\item Una stringa \(P = p_1 \ldots p_m\) (\emph{pattern})
	\item Una stringa \(T = p_1 \ldots p_n\) (\emph{testo}), con \(m \leqslant n\)
\end{itemize}

\begin{definition}[occorrenza \(k\)-approssimata]
Un’occorrenza \(k\)-approssimata di un \emph{pattern}(\(P\)) in un \emph{testo}\(T\), con \(0 \leqslant k \leq m\), è una copia di \(P\) in \(T\) in cui sono ammessi \(k\) \enquote{errori} (o differenze) tra caratteri di \(P\) e caratteri di \(T\), del seguente tipo:
\end{definition}

\begin{enumerate}
	\item i corrispondenti caratteri in \(P\) e in \(T\) sono diversi (\emph{sostituzione});
	\item un carattere in $P$ non è incluso in $T$ (\emph{inserimento});
	\item un carattere in $T$ non è incluso in $P$ (\emph{cancellazione}).
\end{enumerate}

L'obiettivo è trovare un’occorrenza \(k\)-approssimata di \(P\) in \(T\) per cui \(k\) sia minimo.
% TODO Ossia trovare il numero di caratteri minimo che serve per

\begin{definition}[tabella di programmazione dinamica]
Sia \(DP[0 \ldots m, 0 \ldots n]\) una tabella di programmazione dinamica tale che \(DP[i][j]\) contiene il minimo valore \(k\) per cui esiste un'occorrenza \(k\)-approssimata di \(P(i)\) in \(T(j)\), che termina nella posizione \(j\).
\end{definition}

Esistono quattro possibilità:
\begin{enumerate}
	\item \makebox[4.5cm][l]{\(DP[i-1][j-1]\), se \(p_i = t_j\)} avanza su entrambi i caratteri;
	\item \makebox[4.5cm][l]{\(DP[i-1][j-1]+1\), se \(p_i \Neq t_j\)} avanza su entrambi i caratteri  (\emph{sostituzione});
	\item \makebox[4.5cm][l]{\(DP[i-1][j]+1\)} avanza sul pattern (\emph{inserimento});
	\item \makebox[4.5cm][l]{\(DP[i][j-1]+1\)} avanza sul testo (\emph{cancellazione}).
\end{enumerate}

% NOTE è la stessa cosa
\begin{comment}
\begin{table}[H]
	\begin{tabular}{@{} l l l @{}}
		1. & \(DP[i-1][j-1]\), se \(p_i = t_j\)		& avanza su entrambi i caratteri (uguali) \\
		2. & \(DP[i-1][j-1]+1\), se \(p_i \Neq t_j\) & avanza su entrambi i caratteri  (\emph{sost.}) \\
		3. & \(DP[i-1][j]+1\)						& avanza sul pattern (\emph{inserimento})\\
		4. & \(DP[i][j-1]+1\)						& avanza sul testo (\emph{cancellazione})\\
	\end{tabular}
\end{table}
\end{comment}

Ricostruzione della soluzione finale:
\begin{itemize}
	\item \(DP[m][j] = k\) se e solo se esiste un’occorrenza \(k\)-approssimata di \(P\) in \(T(j)\) che termina nella posizione \(j\);
	\item La soluzione del problema è data dal più piccolo valore \(DP[m][j]\), per \(0 \leqslant j \leqslant n\).
\end{itemize}

\begin{figure}[H]\centering
	%
	\begin{subfigure}[b]{.48\linewidth}
		\centering
		\includestandalone[mode=buildnew, width=.5\linewidth]{assets/figures/13/table_asm}
		\caption{figura 1}%
		\label{fig:etichetta}
	\end{subfigure}
	%
	\begin{subfigure}[b]{.48\linewidth}
		\centering
		\includestandalone[mode=buildnew, width=.5\linewidth]{assets/figures/13/table_asm-2-test}
		\caption{figura 2}%
		\label{fig:etichetta}
	\end{subfigure}
	%
	% \caption{didascalia}
\end{figure}

\includestandalone{assets/algorithms/13/stringMatching}

\begin{note}
Non è detto che la \enquote{soluzione finale} si trovi nella casella \enquote{in basso a destra} ; è invece possibile che la soluzione debba essere ricercata all'interno della tabella.
\end{note}

\subsection{Catena di moltiplicazione di matrici}

\begin{figure}[H]\centering
	\scalebox{0.8}{
		\includestandalone{./assets/figures/13/matrix_multiplication}
	}
	\caption{Moltiplicazione fra matrici}
\end{figure}

Il prodotto fra matrici non è \emph{commutativo} (in quanto le matrici devono essere compatibili righe per colonne) però è \emph{associativo}. %
Vogliamo quindi calcolare il prodotto di una catena di matrici impiegando il minor numero possibile di moltiplicazioni scalari.

Iniziamo caratterizzando matematicamente il nostro problema definendo la parentesizzazione \(P[i \dots j]\) del prodotto \(A_i \cdot A_{i+1 \dots A_j}\) come:

\begin{itemize}
	\item la matrice \(A_i\) se gli indici corrispondono (\(i = j\));
	\item il prodotto di due parentesizzazioni \(P_{i,k} \cdot P_{k+1,j}\) altrimenti.
\end{itemize}

\begin{figure}[H]
	\centering
	\begin{forest} math tree
			[(A_1 \cdot (A_2 \cdot A_3)) \mathcolor{brighter}{\bs{\times}} (A_4 \cdot (A_5 \cdot A_6))
				[(A_1 \cdot (A_2 \cdot A_3))
					[A_1]
						[(A_2 \cdot A_3)
							[A_2]
								[A_3]
						]
				]
				[(A_4 \cdot (A_5 \cdot A_6)
					[A_4]
					[(A_5 \cdot A_6)
						[A_5]
							[A_6]
					]
				]
			]
	\end{forest}
	\caption{In questo caso \(k = 3\) e il prodotto evidenziato è detto \textcolor{brighter}{\emph{ultimo prodotto}}.}
\end{figure}

\subsubsection{Quantificare il numero di parentesizzazioni possibili}

Per trovare la soluzione ottima, nel nostro caso la parentesizzazione ottima (cieè la parentesizzazione che richiede il minor numero di moltiplicazioni scalari per essere completata, fra tutte le parentesizzazioni possibili) dobbiamo essere in grado di quantificarle e calcolarle empiricamente.

La motivazione alla base è che conviene Vale la pena preprocessare i dati per cercare la parentesizzazione migliore, per risparmiare tempo dopo nel calcolo vero e proprio.

Cercare di enumerare tutte le possibili combinazioni (approcciando il problema con la forza bruta) per poi scegliere la parentesizzazione migliore \emph{non è possibile}, in quanto le combinazioni crescono come i numeri catalani (esponenzialmente) il che non ci permette di scrivere un algoritmo polinomiale, ma bensì esponenziale.

\begin{figure}[H]
	\begin{equation*}
		P(n) =
		\begin{dcases}
			1                            & n = 1 \\
			\sum_{i=1}^{n-1} P(k) P(n-k) & n > 1 \\
		\end{dcases}
	\end{equation*}
	\caption{numero di parentesizzazioni per n matrici \(A_1 \cdot \dotso \cdot A_n\). \(P(n) = \Omega(2^n)\)}
	\label{}
\end{figure}

Aggiungiamo un po' di notazione matematica per semplificare la scrittura:

\begin{table}[H]
	\centering
	\begin{tabular}{@{} l l @{}}
		\toprule
		notazione\dots                        & \dots indica                                      \\
		\lightrule
		\(A_1 \cdot A_2 \cdot A_3 \dots A_n\) & il prodotto di \(n\) matrici da ottimizzare       \\
		\lightrule
		\(c_{i - 1}\)                         & il numero di \emph{righe} della matrice \(A_i\)   \\
		\lightrule
		\(c_i\)                               & il numero di \emph{colonne} della matrice \(A_i\) \\
		\lightrule
		\(A[i \dots j]\)                      & il sottoprodotto \(A_i \cdot A_{i + 1} \cdot
		\dotso \cdot A_j\)                                                                        \\
		\lightrule
		\(P[i \dots j]\)                      & una parentesizzazione per \(A[i \dots j]\)        \\
		\bottomrule
	\end{tabular}
	\caption{Definizioni matematiche}
\end{table}

\begin{note}
\(P[i \dots j]\) non dev'essere necessariamente una parentesizzazione ottima.
\end{note}

Indipendentemente dalle operazioni che facciamo il risultato avrà sempre il numero di righe della prima matrice ed il numero di colonne dell'ultima matrice.

\begin{theorem}[sottostruttura ottima]
	Se \(P[i \dots j] = P[i \dots k] \cdot P[k + 1 \dots j]\) è una parentesizzazione ottima del prodotto \(A[i \dots j]\), allora:
	\begin{itemize}
		\item \(P[i \dots k]\) è una parentesizzazione ottima del prodotto \(A[i \dots k]\);
		\item \(P[k + 1 \dots j]\) è una parentesizzazione ottima del prodotto \(A[k+1 \dots k]\).
	\end{itemize}
\end{theorem}

\begin{proof}[Dimostrazione per assurdo]
	Supponiamo esista un parentesizzazione ottima (diversa) \(P'[i \dots k]\) di \(A[i \dots k]\) con costo inferiore a \(P[i \dots k]\).

	Allora, la moltiplicazione \(P'[i \dots k] \cdot P'[k+1 \dots j]\) sarebbe una parentesizzazione di \(A[i \dots j]\) con costo inferiore a quella ottima \(P[i \dots j]\), ma siccome quella ottima deve avere un costo minimo questo è assurdo.
\end{proof}

In altre parole il teorema afferma che esiste una \emph{sottostruttura ottima}. %
Ogni soluzione ottima al problema della parentesizzazione contiene al suo interno le soluzioni ottime dei due sottoproblemi.

L’esistenza di sottostrutture ottime ci indica che in questo problema, \emph{la programmazione dinamica è applicabile}.

Proseguiamo quindi defininendo ricorsivamente il costo di una soluzione ottima.

\subsubsection{Valore della soluzione ottima}

Sia \(DP[i][j]\) il minimo numero di moltiplicazioni scalari necessarie per calcolare il prodotto \(A[i \dots j]\).
\begin{itemize}
	\item \fbox{caso base: \(i = j\)} %
		  Allora \(DP[i][j] = 0\) (non è necessario effettuare moltiplicazioni)

	\item \fbox{caso ricorsivo \(i < j\)} %
		  Esiste una parentesizzazione ottima
		  \[P[i \dots j] = P[i \dots k] \cdot P[k + 1 \dots j]\]
		  che può essere definita (sfruttando la ricorsione)
		  \[DP[i][j] = DP[i][k] + DP[k + 1][j] + c_{i-1} \cdot c_k \cdot c_j\]
\end{itemize}

\begin{note}
	\(c_{i-1} \cdot c_k \cdot c_j\) è il costo della moltiplicazione delle \(c_{i-1}\) righe della prima matrice per le \(c_k\) colonne della seconda matrice (che corrispondono alle righe della terza matrice), il cui risultato viene a sua volta moltiplicato per le \(c_j\) colonne della quarta matrice.
\end{note}

Non posso sapere a priori quale sia il valore ottimale per \(k\) quindi li provo tutti prendendo in considerazione che può assumere tutti i valori fra \(i\) e \(j-1\). %
Ad esempio se ho tre matrici \(A_1, A_2, A_3\) le due parentesizzazioni possibili sono \(((A_1 \cdot A_2) \cdot A_3)\) e \((A_1 \cdot (A_2 \cdot A_3))\) quindi \(k\) può assumere valori da 1 a 2.
\[
	DP[i][j] =
	\begin{dcases}
		0 & i = j \\
		\underset{i \leqslant k < j}{min} \{DP[i][k] + DP[k+1][j] + c_{i-1} \cdot c_{k} \cdot c_j\} & i < j \\
	\end{dcases}
\]

\subsubsection{Dalla formula al codice}

\begin{comment}
\begin{fquote}[Donald Knuth]%
	An algorithm must be seen to be believed, and the best way to learn what an algorithm is all about is to try it
\end{fquote}
\end{comment}

Le frecce uniscono i costi che devono essere sommati fra di loro.

\subsubsection*{Approccio top-down}

\includestandalone{assets/algorithms/13/par-recursive}

\paragraph{Complessità}
% TODO: impostare correttamente cleverref
Un'approccio ricorsivo top-down alla risoluzione del problema è illustrato nell'algoritmo \recPar.
\'E possibile dimostrare che l'algoritmo è \(\Omega(2^n)\), che non è poi tanto meglio dell'approccio basato su forza bruta.
Questa complessità deriva dal fatto che molti sottoproblemi vengono risolti più volte.
\'E proprio in casi come questi che la programmazione dinamica ci viene incontro.

\subsubsection*{Approccio bottom-up}

Utilizziamo quindi due tabelle per contenere i risultati intermedi:

\begin{enumerate}
	\item \(DP[i][j]\) contiene il numero di moltiplicazioni scalari necessarie per moltiplicare le matrici \(A[i \dots j]\);
	\item \(last[i][j]\) contiene il valore \(k\) dell’ultimo prodotto che minimizza il costo per il sottoproblema.
\end{enumerate}

\includestandalone{assets/algorithms/13/par-compute}

L'algoritmo lavora per riempiendo una diagonale alla volta tramite la variabile \(h\) il cui valore varia sulle diagonali sopra quella principale, mentre \(i\) e \(j\) assumono valori delle celle nella diagonale \(h\). %
Infatti la variabile \(i\) assume valori che variano da \(1\) a \(n-h+1\).
Ad esempio al primo ciclo \(i=1\), \(h=2\) e la variabile \(i\) assumerà il valore di \(6-2+1=5\) evitando così di toccare la diagonale principale.
Discorso analogo per la variabile \(j\).

L'algoritmo calcola tutti i possibili valori e conserva solo il più piccolo.
A differenza dell'algoritmo precedente non svogliamo più chiamate ricorsive ma riutilizziamo valori già calcolati.

\begin{itemize}
	\item Un vettore \(c[0 \ldots n]\) contenente le dimensioni delle matrici;
		  \begin{itemize}
			  \item \(c[0]\) è il numero di righe della prima matrice
			  \item \(c[i-1]\) è il numero di righe della matrice \(A_i\)
			  \item \(c[i]\) è il numero di colonne della matrice \(A_i\)
		  \end{itemize}
	\item Due indici \(i\), \(j\) che rappresentano l'intervallo di matrici da moltiplicare;
	\item Il costo della funzione si trova nella posizione \(DP[1,n]\).
\end{itemize}

\bigskip
\begingroup
\renewcommand*{\arraystretch}{1.0}
\begin{minipage}[t]{0.12\linewidth}
	\begin{tabular}{cc}\toprule
		\(i\) & \(c[i]\) \\\midrule
		0     & 7        \\\lightrule
		1     & 8        \\\lightrule
		2     & 4        \\\lightrule
		3     & 2        \\\lightrule
		4     & 3        \\\lightrule
		5     & 5        \\\lightrule
		6     & 6        \\\bottomrule
	\end{tabular}
\end{minipage}
\begin{minipage}[t]{0.47\linewidth}
	\begin{tabular}{!>{\bfseries}r^r^r^r^r^r^r}\toprule\rowstyle{\bfseries}
		\normalfont{\emph{DP}} & 1 & 2 & 3  & 4           & 5   & 6   \\\midrule
		1 & \phantom{00}0 & \blink{224} & \blink{176} & \alert{218} & 276 & 350 \\\lightrule
		2                      &   & 0 & 64 & \blink{112} & 174 & 250 \\\lightrule
		3                      &   &   & 0  & \blink{24}  & 70  & 138 \\\lightrule
		4                      &   &   &    & 0           & 30  & 90  \\\lightrule
		5                      &   &   &    &             & 0   & 90  \\\lightrule
		6                      &   &   &    &             &     & 0   \\\bottomrule
	\end{tabular}
\end{minipage}%
\begin{minipage}[t]{0.4\linewidth}
	\begin{tabular}{!>{\bfseries}r^r^r^r^r^r^r}
		\toprule\rowstyle{\bfseries}
		\last & 1 & 2 & 3 & 4 & 5 & 6 \\\midrule
		1     & \phantom{00}0 & \phantom{00}1 & \phantom{00}1 & \phantom{00}\alert{3} & \phantom{00}3 & \phantom{00}3 \\\lightrule
		2     &   & 0 & 2 & 3 & 3 & 3 \\\lightrule
		3     &   &   & 0 & 3 & 3 & 3 \\\lightrule
		4     &   &   &   & 0 & 4 & 5 \\\lightrule
		5     &   &   &   &   & 0 & 5 \\\lightrule
		6     &   &   &   &   &   & 0 \\\bottomrule
	\end{tabular}
\end{minipage}

\bigskip

\begin{center}
\setlength{\tabcolsep}{3pt}
\begin{tabular}{@{} lll @{} l @{} lllll @{} l @{}}
	\(DP[1][4]\) & \(=\) & \(min_{1 \leq k < 4}\) & \{ & \(DP[1,k]\) & $+$   & \(DP[k+1,4]\) & \(+\) & $c_0 \cdot c_k \cdot c_4\)  & \} \\[5pt]
				 & \(=\) & \(min\)                & \{ & \(DP[1,1]\) & \(+\) & \(DP[2,4]$    & \(+\) & $c_0 \cdot c_1 \cdot c_4,\)      \\
				 &       &                        &    & \(DP[1,2]\) & \(+\) & \(DP[3,4]$    & \(+\) & $c_0 \cdot c_2 \cdot c_4,\)      \\
				 &       &                        &    & \(DP[1,3]\) & \(+\) & \(DP[4,4]$    & \(+\) & $c_0 \cdot c_3 \cdot c_4\)  & \} \\[5pt]
				 & \(=\) & \(min\)                & \{ & 0           & \(+\) & 112           & \(+\) & $7 \cdot 8 \cdot 3,\)            \\
				 &       &                        &    & 224         & \(+\) & 24            & \(+\) & $7 \cdot 4 \cdot 3,\)            \\
				 &       &                        &    & 176         & \(+\) & 0             & \(+\) & $7 \cdot 2 \cdot 3\)        & \} \\[5pt]
				 & \(=\) & \(min\)                & \{ & 280         & \(,\) & 332           & \(,\) & \alert{218}                 & \} \\
\end{tabular}
\end{center}
\endgroup

\paragraph{Complessità}
Il costo computazionale è \(\Omicron(n^3)\) in quanto ogni cella richiede, nel caso peggiore, un tempo \(\Omicron(n)\) per essere riempita.

% TODO mancano dei dettagli

\subsubsection{Ricostruzione della soluzione ottima}

\'E inoltre necessario mostrare la soluzione trovata, per questo motivo abbiamo registrato informazioni sulla soluzione nella matriche \emph{last}.

Possiamo quindi definire un algoritmo che ricostruire l'informazione a partire dall'informazione calcolata: \(last[i,j]\) contiene il valore \(k\) su cui dobbiamo spezzare il prodotto \(A[i \dots j]\).
Ci suggerisce quindi che per calcolare \(A[i \dots j]\) dobbiamo prima calcolare \(A[i \dots k]\) e \(A[k+1 \dots j]\) e poi moltiplicarle fra di loro.
Questo processo è facilmente realizzabile tramite un algoritmo \emph{ricorsivo}.

Modifichiamo leggermente la funzione sopra nel modo seguente:
\begin{algorithm}
\caption{Stuff}

	\prototype{\computePar{\Int c, \Int i, \Int n}}{
		\omitted\;
		\printPar\((\ArrayCall{last}{}, 1, n)\)\;
	}

	\input{assets/algorithms/13/par-print}

\end{algorithm}

% La funziona stampa semplicemente il risultato.

\subsubsection{Calcolo effettivo}

La funziona sopra si limita a stampare la soluzione ma noi vogliamo effettuare il calcolo effettivo della soluzione.

\includestandalone{assets/algorithms/13/par-multiply}

Facendo un esempio

\bigskip
\begin{minipage}{.5\linewidth}
	\begin{align*}
		A[1 \ldots 6] & = A[1 \ldots 3] \cdot A[4 \ldots 6] \\
		A[1 \ldots 3] & = A_1 \cdot A[2 \ldots 3]           \\
		A[4 \ldots 6] & = A[4 \ldots 5] \cdot A_6           \\
		A[2 \ldots 3] & = A_2 \cdot A_3                     \\
		A[4 \ldots 5] & = A_4 \cdot A_5
	\end{align*}
\end{minipage}
\begin{minipage}{.4\linewidth}
	\begin{tabular}{ !>{\bfseries}r ^r ^r ^r ^r ^r ^r}
		\toprule\rowstyle{\bfseries}
		\last & 1 & 2 & 3 & 4 & 5 & 6 \\\midrule
		1 & \phantom{00}0 & \phantom{00}1 & \phantom{00}1 & \phantom{00}3 & \phantom{00}3 & \phantom{00}3 \\\lightrule
		2     &   & 0 & 2 & 3 & 3 & 3 \\\lightrule
		3     &   &   & 0 & 3 & 3 & 3 \\\lightrule
		4     &   &   &   & 0 & 4 & 5 \\\lightrule
		5     &   &   &   &   & 0 & 5 \\\lightrule
		6     &   &   &   &   &   & 0 \\\bottomrule
	\end{tabular}
\end{minipage}

\bigskip
Che risulta in \( A = ( ( A_1 \cdot  (A_2 \cdot A_3) ) \cdot ( (A_4 \cdot A_5 )  \cdot A_6) ) \)

\begin{note}
A volte, bisogna fare attenzione a come riempire la tabella -- non è detti che riempire una riga dopo l'altra sia possibile.
\end{note}

\subsection{Insieme indipendente di intervalli pesati}

\begin{note}
Questo problema non è risolvibile solo tramite la programmazione dinamica.
\end{note}

\subsubsection{Definizione del problema}

Siano dati \(n\) intervalli distinti \([a_1, b_1[, \ldots, [a_n, b_n[\) della retta reale, aperti a destra, dove all’intervallo \(i\) è associato un profitto \(w_i, 1 \leqslant i \leqslant n\).

\begin{definition}[Intervalli disgiunti]
Due intervalli \(i\) e \(j\) si dicono \emph{disgiunti} se:  \(b_j \leqslant a_i\)  oppure  \(b_i \leqslant a_j\).
\end{definition}

L'obiettivo è trovare un \emph{insieme indipendente di peso massimo}, ovvero un sottoinsieme di intervalli disgiunti tra loro tale che la somma dei loro profitti sia la più grande possibile. %
La una prenotazione di una sala conferenze è un esempio di questo genere di problemi. %
Riesci a trovare la soluzione ottima? La soluzione si trova sulla pagina successiva.

\begin{figure}[H]
	\centering
	\includestandalone{./assets/figures/13/gantt}
	\caption{Un esempio di intervalli disgiunti: prenotazione di una sala conferenze, a sinistra sono indicati i \emph{pesi} di ogni intervallo}%
	\label{fig:gantt}
\end{figure}

\subsection{Pre-elaborazione}

\subsubsection{Implementazione naive}

Per usare la programmazione dinamica è necessario effetuare una pre-elaborazione: ordinare gli intervalli per estremi finali crescenti (per ordine di fine) \(b_1 \leqslant b_2 \leqslant \dots \leqslant b_n\).

\(DP[i]\) contiene il profitto massimo ottenibile con i primi \(i\) intervalli.

\begin{figure}[H]
	\begin{equation*}
		DP[i] =
		\begin{dcases}
			0 & i = 0 \\
			\max (DP[i-1],\ \mathcolor{mathcolor}{\max \{ DP[j] + w_i \colon 1 \leqslant j < i \land b_j \leqslant a_i \}} ) & i > 0
		\end{dcases}
	\end{equation*}
	\caption[pre-elaborazione intervalli pesati prima versione]{Prima versione}
\end{figure}

Devo compiere una scelta (e la scelta migliore è rappresentato dal fatto che scelgo quella con \emph{profitto massimo}), le possibilità sono due:

\begin{itemize}
	\item Non prendo l'intervallo, quindi tolgo un elemento (\(DP[i-1]\));
	\item Prendo l'elemento, posso compiere questa scelta solo se l'intervallo è \emph{compatibile} (ovvero se \( j < i \) e (devono valere entrambe le proprietà) se l'intervallo finisce prima dell'inizio dell'intervallo considerato (\( b_j \leqslant a_i \))).
\end{itemize}

\begin{figure}[H]\centering
	\includestandalone{assets/figures/13/gantt_pd}
	\caption{Soluzione ottima}%
	\label{fig:gantt-solution-pd}
\end{figure}

\paragraph{Complessità}
Il costo computazionale associato a questa formula è \(\Omicron(n^2)\) perché per ognuno degli intervalli devo guardare tutti gli altri.

\subsubsection{Pre-calcolo dei predecessori}

Una seconda possibile pre-elaborazione consiste nel pre-calcolare il \emph{predecessore} \(pred_i\) di \(i\), dove \(j\) si riferisce all'intervallo subito antecedente a quello considerato (\( j < i \) è il massimo indice tale che \( b_j \leqslant a_i \))

\begin{figure}[H]\centering
	\includegraphics{assets/figures/13/gantt_part}
	\caption{Predecessore}%
	\label{fig:pred}
\end{figure}

\begin{figure}[H]
	\[
		DP[i] =
		\begin{dcases}
			0 & i = 0 \\
			\max (DP[i-1],\ \mathcolor{mathcolor}{DP[\mathit{pred}_i] + w_i)} & i > 0
		\end{dcases}
	\]
	\caption[pre-elaborazione intervalli pesati seconda versione]{Seconda versione}
	\label{}
\end{figure}

L'algoritmo di calcolo dei predecessori è illustrato di seguito

\includestandalone{assets/algorithms/13/intervals-pred}

\paragraph{Complessità}
Pre-calcolare i predecessori viene a costare \(\Omicron(n^2)\), ma si può fare meglio di così.

\includestandalone{assets/algorithms/13/intervals-dp}

\paragraph{Complessità}
La complessità di questa funzione è la sommatoria asintotica di tutte le sue parti

\begin{table}[H]
	\centering
	\begin{tabular}{@{} !l ^l @{}}\toprule\rowstyle{\bfseries}
		Funzione						& Costo						\\\midrule
		Ordinamento intervalli			& \(\Omicron(n \log n)\)	\\\lightrule
		Calcolo predecessori			& \(\Omicron(n \log n)\)	\\\lightrule
		Riempimento tabella \emph{DP} 	& \(\Omicron(n)\) 			\\\lightrule
		Ricostruzione soluzione			& \(\Omicron(n)\)			\\\cmidrule{2-2}
										& \(\Omicron(n \log n)\)	\\\bottomrule
	\end{tabular}
\end{table}

\begin{note}
Talvolta, può essere necessario pre-processare l'input per poter applicare nella maniera più efficiente possibile la programmazione dinamica.
\end{note}

\subsection{Conclusioni}

La programmazione dinamica non è la soluzione di tutti i vostri problemi.
Esistono altre tecniche che possono fare \enquote{meglio di così}.
Inoltre, è possibile che soluzioni ad-hoc possano essere migliori.

\end{document}
