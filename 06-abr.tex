%&00-main.preamble

% NOTE ora uso il preambolo precompilato
% NOTE questo √® il "vecchio" preambolo
% \documentclass[00-main.tex]{subfiles}

\setcounter{section}{5}
\pagestyle{footer}

\title{Alberi Binari di Ricerca}

% \captionsetup[figure]{format=hang, justification=raggedright, singlelinecheck=off}
% \captionsetup[subfigure]{format=hang, justification=raggedright, singlelinecheck=off}

% arara: pdflatex: { draft: yes, synctex: no }
% arara: pdflatex: { synctex: yes }
% arara: latexmk: { clean: partial }
\begin{document}
% \maketitle

\section{Alberi Binari di Ricerca}

Facciamo un breve ripasso della struttura dati dizionario.

La struttura dati dizionario √® un insieme dinamico che implementa le seguenti funzionalit√†:
\begin{itemize}
	\item \Item \dictLookup{\Item \(v\)} permette di cercare per una certa chiave
	\item \dictInsert{\Item \(k\), \Item \(v\)} permette di associare una chiave ad un valore
	\item \dictRemove{\Item \(k\)} permette di rimuovere una certa associazione chiave-valore
\end{itemize}

\begin{table}[H]
	\centering
	% \captionsetup{format=hang}
	\caption{Possibili implementazioni della struttura dati dizionario\\e delle relative complessit√†}
	\label{tab:complessita-implementazioni-dizionario}
	\begin{tabular}{@{} l *{3}{c} @{}}
	\toprule
		Struttura dati & \dictLookup & \dictInsert & \dictRemove\\
	\midrule
	Vettore ordinato & \(\Omicron(\log n)\) & \(\Omicron(n)\) & \(\Omicron(n)\)\\
	Vettore non ordinato & \(\Omicron(n)\) & \({\Omicron(1)}^{*}\) & \({\Omicron(1)}^{*}\)\\
	Lista non ordinata & \(\Omicron(n)\) & \({\Omicron(1)}^{*}\) & \({\Omicron(1)}^{*}\)\\
	\bottomrule
	\end{tabular}

	\smallskip
	\small
	* assumendo che l'elemento sia gi√† stato trovato
\end{table}

Ora vedremo la struttura dati dizionario implementata come un albero binario di ricerca.

\medskip
L'idea che ha portato allo sviluppo degli alberi binari di ricerca √® quella di portare la ricera binaria (o dicotomica) negli alberi, avendo quindi un meccanismo dinamico per la memorizzazione delle informazioni ma sulla ricerca binaria per recuperarle.

Le associazioni chiave-valore vengono memorizzate in un albero binario.
Ogni nodo contiene una coppia (\(k\).\varKey, \(u\).\varValue).
Le chiavi devono appartene ad un insieme \emph{totalmente ordinato}, ossia dev'essere possibile stabilire, date due chiavi, stabilire una relazione di precendenza fra di loro.

\begin{property*}[]
Le seguenti propriet√† permettono di realizzare un algoritmo di ricerca dicotomica:
\begin{enumerate}
	\item Le chiavi contenute nei nodi del sottoalbero sinistro di \(u\) sono minori di \(u\).\varKey
	\item Le chiavi contenute nei nodi del sottoalbero destro di \(u\) sono maggiori di \(u\).\varKey
\end{enumerate}
\end{property*}

\begin{note}
Queste propriet√† valgono per ogni nodo e riguardano l'intero sottoalbero.
\end{note}

Vedremo un algoritmo per verificare se un albero binario √® un albero binario di ricerca pi√π avanti (\verifyABR), il quale controller√† se queste propriet√† sono soddisfatte.

% \includestandalone{assets/algorithms/06/verifyABR}

\includestandalone{assets/algorithms/06/tree-abr-interface}

\subsubsection*{Ricerca di un nodo}

\includestandalone{assets/algorithms/06/dict-abr-lookup}

\subsubsection*{Ricerca del minimo e del massimo}

\includestandalone{assets/algorithms/06/dict-abr-min-max}

\subsubsection*{Ricerca del predecessore, successore}

\includestandalone{assets/algorithms/06/dict-abr-succ-pred}

\begin{enumerate}[label={\footnotesize\ttfamily (\arabic*)}]
	\item \(u\) ha figlio sinistro: il successore √® il minimo del sottoalbero destro di \(u\);
	\item \(u\) non ha figlio sinistro: risalendo attraverso i padri, il sucessore √® il primo avo \(v\) tale per cui \(u\) sta nel sottoalbero sinistro di \(v\);
	\item \(u\) ha figlio destro: il successore √® il minimo del sottoalbero destro di \(u\);
	\item \(u\) non ha figlio destro: risalendo attraverso i padri, il sucessore √® il primo avo \(v\) tale per cui \(u\) sta nel sottoalbero sinistro di \(v\).
\end{enumerate}

\clearpage
\subsubsection*{Inserimento di un nodo}

La funzione \insertNode inserisce un'associazione chiave-valore \((k,v)\) nell'albero \(T\).
Se la chiave √® gi√† presente, sostituisce il valore associato;
altrimenti, viene inserita una nuova associazione.
Se l'albero √® vuoto (\(T \Equal \Nil\)) restituisce il primo nodo dell'albero, altrimenti restituisce l'albero \(T\) inalterato.

La funzione ausiliaria \shortcut si occupa di inserire il nodo collegandolo al corretto genitore.

\NoCaptionOfAlgo
\algorithmstyle{ruled}
\begin{algorithm}[H]
	\caption{Implementazione \textsc{Dictionary} con \textsc{ABR}}
	\input{assets/algorithms/06/dict-abr-insert}
	\input{assets/algorithms/06/dict-abr-insertNode}
	\input{assets/algorithms/06/shortcut}
\end{algorithm}
\algorithmstyle{tworuled}

\clearpage
\subsubsection*{Rimozione di un nodo}

Rimuove il nodo contenente la chiave \(k\) dall'albero \(T\), restituisce la radice dell'albero (potenzialmente cambiata).

\NoCaptionOfAlgo
\algorithmstyle{ruled}
\begin{algorithm}[H]
	\caption{Implementazione della rimozione di un nodo in un \textsc{Dictionary} realizzato tramite \textsc{ABR}}
	\input{assets/algorithms/06/dict-abr-remove}
	\input{assets/algorithms/06/dict-abr-removeNode}
	% \input{assets/algorithms/06/shortcut}
	\algorithmstyle{tworuled}
\end{algorithm}

\clearpage
\begin{enumerate}[label={\footnotesize\ttfamily (\arabic*)}]
	\item se il nodo da eliminare \(u\) non ha figli: lo si elimina semplicemente, in quanto togliere una foglia non altera le propriet√† di ordinamento dell'albero;
	% NOTE aggiustamenti per fare rientrare tutto in una pagina
	\vspace{-5pt}
	\begin{figure}[H]\centering
		\hfill
		\begin{subfigure}[t]{.3\linewidth}
			\includegraphics[width=\linewidth, page=1]{assets/figures/06/tree-abr-delete1}
			\caption{Individuazione nodo foglia}
		\end{subfigure}
		\hfill
		\begin{subfigure}[t]{.3\linewidth}
			\includegraphics[width=\linewidth, page=2]{assets/figures/06/tree-abr-delete1}
			\caption{Rimozione del nodo foglia}
		\end{subfigure}
		\hfill\null
	\end{figure}
	% NOTE aggiustamenti per fare rientrare tutto in una pagina
	\vspace{-15pt}
	\item se il nodo da eliminare ha un solo figlio \(f\) (destro o sinistro): si elimina \(u\) e si collega \(f\) all'ex-padre \(p\) di \(u\) in sostituzione di \(u\) (tramite la funzione \shortcut);
	le propriet√† di ordinamento non vengono alterate in quanto tutti i nodi del sottoalbero destro di \(p\) sono maggiori di \(p\) stesso;
	% NOTE aggiustamenti per fare rientrare tutto in una pagina
	\vspace{-5pt}
	\begin{figure}[H]
		\begin{subfigure}[t]{.3\linewidth}
			\includegraphics[width=\linewidth, page=3]{assets/figures/06/tree-abr-delete1}
			\caption{Individuazione nodo \(u\) da eliminare}
		\end{subfigure}
		\hfill
		\begin{subfigure}[t]{.3\linewidth}
			\includegraphics[width=\linewidth, page=4]{assets/figures/06/tree-abr-delete1}
			\caption{Rimozione nodo \(u\)}
		\end{subfigure}
		\hfill
		\begin{subfigure}[t]{.3\linewidth}
			\includegraphics[width=\linewidth, page=5]{assets/figures/06/tree-abr-delete1}
			\caption{Collegamento del sottoalbero \(f\) di \(u\) al padre \(p\) di \(u\)}
		\end{subfigure}
	\end{figure}
	% NOTE aggiustamenti per fare rientrare tutto in una pagina
	\vspace{-15pt}
	\item se il nodo da eliminare \(u\) ha due figli: cerchiamo di ricadere nel caso {\footnotesize\ttfamily (2)};
	\begin{enumerate*}
		\item individuiamo il successore (predecessore) \(s\) di \(u\), il quale √® il pi√π piccolo valore maggiore di \(u\) (il pi√π grande valore minore di \(u\)) e di conseguenza non ha figli sinistri (non ha figli destri);
		\item si \enquote{stacca} il successore \(s\);
		\item si collega l'eventuale figlio destro di \(s\) al padre (tramite la funzione \shortcut) in quanto trovandosi nel sottoalbero sinistro del nonno vuol dire che sicuramente il suo valore non √® maggiore del padre di \(s\);
		\item si copia \(s\) su \(u\), si rimuove il nodo \(s\), cos√¨ facendo rispetto comunque l'ordine parziale.
	\end{enumerate*}
	% NOTE aggiustamenti per fare rientrare tutto in una pagina
	\vspace{-5pt}
	\begin{figure}[H]
		\hfill
		\begin{subfigure}[t]{.45\linewidth}
			\includegraphics[width=\linewidth, page=2]{assets/figures/06/tree-abr-delete2}
			\caption{Individuiamo il successore \(s\) di \(u\)}
		\end{subfigure}
		\hfill
		\begin{subfigure}[t]{.45\linewidth}
			\includegraphics[width=\linewidth, page=3]{assets/figures/06/tree-abr-delete2}
			\caption{Si \enquote{stacca} il successore \(s\)}
		\end{subfigure}
		\hfill\null

		\vspace{10pt}

		\hfill
		\begin{subfigure}[t]{.45\linewidth}
			\includegraphics[width=\linewidth, page=4]{assets/figures/06/tree-abr-delete2}
			\caption{Si collega l'eventuale figlio destro di \(s\) al padre}
		\end{subfigure}
		\hfill
		\begin{subfigure}[t]{.45\linewidth}
			\includegraphics[width=\linewidth, page=5]{assets/figures/06/tree-abr-delete2}
			\caption{Si copia \(s\) su \(u\), si rimuove il nodo \(s\)}
		\end{subfigure}
		\hfill\null

		% NOTE rimosso perch√© la spiegazione risulta ugualmente chiara, e perch√© ci sta tutto in una pagina diciamocelo üòÑ
		% \vspace{10pt}
		%
		% \hfill
		% \begin{subfigure}[t]{.45\linewidth}
		% 	\includegraphics[width=\linewidth, page=5]{assets/figures/06/tree-abr-delete2}
		% 	\caption{bla bla bla}
		% \end{subfigure}
		% \hfill\null
	\end{figure}
\end{enumerate}

\clearpage
\subsubsection*{Costo computazionale delle operazioni}

Tutte le operazioni sono confinate ai nodi posizionati lungo un cammino semplice dalla radice ad una foglia.
Quindi se l'altezza dell'albero √® definita come \(h\), il tempo di ricerca ha complessit√† \(\Omicron(h)\).

\medskip
Il caso pessimo √® rappresentanto da un albero sbilanciato completamente a destra o completamente a sinistra.
Questo caso pu√≤ accadere quando si inseriscono ordinatamente i dati nell'albero.
Questo caso, dove l'altezza \(h = n\) porta ad una complessit√† \(\Omicron(n)\).

\smallskip
Mentre il caso ottimo √® rappresentanto da un albero bilanciato.
Nell'esempio √® mostrato un albero perfetto con \(2^h - 1\) nodi, dove \(h\) √® l'altezza.
In questo caso la complessit√† √® pari a \(\Omicron(\log n)\), ad esempio con \(h = 2^3 - 1\) la complessit√† √® \(\Omicron(\log h) = \Omicron(\log 7) < 3\).

\smallskip
Ci domandiamo quindi quale sia l'altezza media di un albero binario di ricerca.
Il caso \enquote{semplice} √® quello di considerare che gli inserimenti avvengano in maniera statisticamente uniforme, √® possibile dimostrare che l'altezza media √® \(\Omicron(\log n)\), mentre il caso generale, ossia quello in cui avvengono sia inserimenti che cancellazioni √® di difficile trattazione. Per evitare questa casisistica si utilizzano varie tecniche per mantenere l'albero bilanciato.
Per capire queste tecniche abbiamo prima bisogno di fissare un concetto.
\begin{definition}[Fattore di bilanciamento]
Il fattore di bilanciamento \(\beta(v)\) di un nodo \(v\) √® la massima differenza di altezza fra i sottoalberi di \(v\).
\end{definition}

Negli anni sono state usate diverse tecnische, ora in disuso:
\begin{itemize}
	\item Alberi AVL (1962): \(\beta(v) \leqslant 1\) per ogni nodo \(v\), il bilanciamento dell'albero avveniva tramite rotazioni;
	\item B-Alberi (1972): \(\beta(v) = 0\) per ogni nodo \(v\), sono specializzati per strutture in memoria secondaria;
	\item Alberi 2-3 (1983): \(\beta(v) = 0\) per ogni nodo \(v\), in cui ogni nodo pu√≤ avere o 2 o 3 figli, se ad un nodo viene aggiunto un ulteriore figlio, il ramo viene spezzato in due rami con 2 figli ciascuno, mentre se ad un ramo con 2 figli ne viene tolto uno allora l'unico figlio rimanente viene collegato al padre, questo potrebbe riportare il problema al primo caso; il bilanciamento viene ottenuto quindi tramite merge/split, il grado √® variabile.
\end{itemize}

\subsubsection*{Meccanismo di rotazione}

Il meccanismo di rotazione ci permette di abbassare il fattore di sbilanciamento rispettando le propriet√† di ordinamento parziale.

\clearpage
\subsection{Alberi Binari di Ricerca bilanciati}

\begin{definition}[Albero Red-Black]
Un albero red-black √® un albero binario di ricerca in cui:
\begin{itemize}
	\item ogni nodo √® colorato di rosso o di nero;
	\item le chiavi vengono mantenute solo nei nodi interni dell'albero;
	\item le foglie sono costituite solo da nodi speciali \textbf{Nil}.
\end{itemize}
\end{definition}

I nodi speciali \textbf{Nil} sono dei nodi sentinella il cui unico scopo √® quello di evitare di trattare diversamente i puntatori ai nodi, dai puntatori \Nil;
infatti al posto di un puntatore \Nil si usa un puntatore ad un nodoo \textbf{Nil};
in memoria ne esiste solo uno per motivi di economia.
I nodi con figli \textbf{Nil} sono le foglie nell'albero binario di ricerca corrispondente.

\medskip
Un albero red-black deve rispettare i seguenti vincoli:
\begin{enumerate}
	\item La radice √® nera;
	\item Tutte le foglie sono nere;
	\item Entrambi i figli di un nodo rossso sono neri;
	\item Ogni cammino semplice da un nodo \(u\) ad una delle foglie contenute nel sottoalbero radicato in \(u\) hanno lo stesso numeo di nodi neri.
\end{enumerate}

\includestandalone{assets/algorithms/06/tree-rb-interface}

\begin{property*}[Altezza nera di un nodo \(v\)]
L'altezza nera \(b(v)\) di un nodo \(v\) √® il numero di nodi neri lungo ogni percorso da \(v\) (escluso) ad ogni foglia (inclusa) del suo sottoalbero.
\end{property*}

\begin{property*}[Altezza nera di un albero Red-Black]
L'altezza nera di un albero Red-Black √® pari all'altezza nera della sua radice.
\end{property*}

Entrambe le propriet√† sono ben definite perch√© tutti i percorsi hanno lo stesso numero di nodi neri (per via della regola no.\ 4).

\subsubsection*{Esempi}

\begin{figure}[H]\centering
	\renewcommand{\subfigurename}{Es.}
	\renewcommand\thesubfigure{\arabic{subfigure}}
	\captionsetup[subfigure]{labelformat=simple, labelsep=space}
	\begin{subfigure}[t]{.48\linewidth}\centering
		\includegraphics[width=\linewidth, page=1]{assets/figures/06/tree-rb-examples}
		\caption{Entrambi i figli di un nodo rosso sono neri (3),\\ma un nodo nero pu√≤ avere figli neri.}
	\end{subfigure}
	\hfill
	\begin{subfigure}[t]{.48\linewidth}\centering
		\includegraphics[width=\linewidth, page=2]{assets/figures/06/tree-rb-examples}
		\caption{Ogni percorso da un nodo interno ad un nodo \textbf{Nil} ha lo stesso numero  di nodi neri (4).\\Altezza nera di quest'albero: 3}
		\vspace{5pt}
	\end{subfigure}

	\begin{lemma}
	L'altezza totale di un albero √® al pi√π il doppio della sua altezza nera.
	\end{lemma}

	\begin{subfigure}[t]{.48\linewidth}\centering
		\includegraphics[width=\linewidth, page=3]{assets/figures/06/tree-rb-examples}
		\caption{Pi√π colorazioni sono possibili (versione 1).\\Altezza di questo albero: 3}
	\end{subfigure}
	\hfill
	\begin{subfigure}[t]{.48\linewidth}\centering
		\includegraphics[width=\linewidth, page=4]{assets/figures/06/tree-rb-examples}
		\caption{Pi√π colorazioni sono possibili (versione 2).\\Altezza di questo albero: 3}
	\end{subfigure}

	\begin{subfigure}[t]{.48\linewidth}\centering
		\includegraphics[width=\linewidth, page=5]{assets/figures/06/tree-rb-examples}
		\caption{Cambiare colorazione pu√≤ cambiare l'altezza nera.\\Altezza di questo albero: 3}
	\end{subfigure}
	\hfill
	\begin{subfigure}[t]{.48\linewidth}\centering
		\includegraphics[width=\linewidth, page=6]{assets/figures/06/tree-rb-examples}
		\caption{Cambiare colorazione pu√≤ cambiare l'altezza nera.\\Stesso albero, altezza nera di questo albero: 2}
	\end{subfigure}
\end{figure}

\begin{comment}
\clearpage
\subsubsection*{Esercizio}

\begin{figure}[ht]
	\caption*{Quasto albero pu√≤ essere un albero Red-Black?}
	\vspace{5pt}
	\includegraphics[width=\linewidth, height=4.5cm, keepaspectratio]{assets/figures/06/tree-rb-question}
\end{figure}
\vfill\null
\clearpage
\end{comment}

\subsubsection{Inserimento di un nodo}

Durante la modifica di un albero Red-Black √® possibile che le condizioni di bilanciamento risultino violate.
Quando i vincoli Red-Black vengono violate si pu√≤ agire in due modi:
\begin{itemize}
	\item modificando i colori nella zona della violazione;
	\item operando dei bilanciamenti dell'albero tramite rotazioni (a destra o a sinistra)
\end{itemize}
\subsubsection{Bilanciamento dell'albero}

\subsubsection*{Rotazione a sinistra}

\includestandalone{assets/algorithms/06/tree-rb-leftRotation}

\begin{note}
I disegno differisce un minimo da quello che si trova sulle slide per motivi di comodit√† nel disegnarli.
\end{note}
\begin{figure}[H]
	\renewcommand\thesubfigure{\arabic{subfigure}}
	\begin{subfigure}[t]{.23\linewidth}
		\includegraphics[width=\linewidth, page=1]{assets/figures/06/tree-rb-leftRotation}
		\caption{Stato attuale}
	\end{subfigure}\hfill
	\begin{subfigure}[t]{.23\linewidth}
		\includegraphics[width=\linewidth, page=2]{assets/figures/06/tree-rb-leftRotation}
		\caption{Il sottoalbero \(B\) diventa figlio dx di \(x\)}
	\end{subfigure}\hfill
	\begin{subfigure}[t]{.23\linewidth}
		\includegraphics[width=\linewidth, page=3]{assets/figures/06/tree-rb-leftRotation}
		\caption{\(x\) diventa figlio sx di \(y\)}
	\end{subfigure}\hfill
	\begin{subfigure}[t]{.23\linewidth}
		\includegraphics[width=\linewidth, page=4]{assets/figures/06/tree-rb-leftRotation}
		\caption{\(y\) diventa figlio di \(p\),\\il vecchio padre di \(x\)}
	\end{subfigure}
	\caption{Esempio di rotazione a sinistra}
\end{figure}

\clearpage
\subsubsection*{Rotazione a destra}

La rotazione a destra √® simmetrica e viene spiegata ed illustrata per completezza.

\includestandalone{assets/algorithms/06/tree-rb-rightRotation}

\begin{figure}[H]
	\renewcommand\thesubfigure{\arabic{subfigure}}
	\begin{subfigure}[t]{.23\linewidth}
		\includegraphics[width=\linewidth, page=1]{assets/figures/06/tree-rb-rightRotation}
		\caption{Stato attuale}
	\end{subfigure}\hfill
	\begin{subfigure}[t]{.23\linewidth}
		\includegraphics[width=\linewidth, page=2]{assets/figures/06/tree-rb-rightRotation}
		\caption{Il sottoalbero \(B\) diventa figlio sx di \(x\)}
	\end{subfigure}\hfill
	\begin{subfigure}[t]{.23\linewidth}
		\includegraphics[width=\linewidth, page=3]{assets/figures/06/tree-rb-rightRotation}
		\caption{\(x\) diventa figlio dx di \(y\)}
	\end{subfigure}\hfill
	\begin{subfigure}[t]{.23\linewidth}
		\includegraphics[width=\linewidth, page=4]{assets/figures/06/tree-rb-rightRotation}
		\caption{\(y\) diventa figlio di \(p\),\\il vecchio padre di \(x\)}
	\end{subfigure}
	\caption{Esempio di rotazione a destra}
\end{figure}

\clearpage
\subsubsection*{Inserimento di un nodo in un albero Red-Black}

Per inserire un nodo in un albero Red-Black si usa la stessa procedura usata per gli alberi binari di ricerca e si colora il nuovo nodo di \RED.
Il vincolo che violeremo √® il terzo, quello che prevede che entrambi i figli di un nodo rosso siano neri.

\NoCaptionOfAlgo
\algorithmstyle{ruled}
\begin{algorithm}[H]
	\caption{Inserimento di un nodo in un \textsc{Red-Black Tree}}
	\input{assets/algorithms/06/tree-br-insertNode}
	% \includestandalone{assets/algorithms/06/tree-br-balanceInsert}
\end{algorithm}
\algorithmstyle{tworuled}

Ci spostiamo verso l'alto lungo il percorso di inserimento;
cercheremo di ripristinare il terzo vincolo;
sposteremo le violazioni verso l'alto rispettando il quarto vincolo (mantenendo l'altezza nera dell'albero);
al termine, coloreremo la radice di nero (rispettando il primo vincolo).

\begin{note}
Le operazioni di ripristino sono necessarie solo quando due nodi consecutivi sono rossi, altrimenti non sono necessarie.
\end{note}

% \subsubsection{Rimozione di un nodo}
%
% A lezione non √® stato spiegato l'algoritmo, viene riportato solo per completezza.

% \NoCaptionOfAlgo
% \algorithmstyle{ruled}
% \begin{algorithm}[H]
% 	\caption{Rimozione di un nodo in un \textsc{Red-Black Tree}}
% 	% \includestandalone{assets/algorithms/06/tree-br-removeNode}
% 	% \includestandalone{assets/algorithms/06/tree-br-balanceDelete}
% \end{algorithm}
% \algorithmstyle{tworuled}

\end{document}
